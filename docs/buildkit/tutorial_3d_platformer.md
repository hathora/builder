# Tutorial: 3D Platformer

In this tutorial we're going to develop a 3D platformer game which can be played in your web browser. This game will leverage the Hathora `BuildKit` client and server libraries to facilitate multiplayer functionality.

Note that this tutorial is aimed at developers who may not have experience with Hathora, TypeScript, or even multiplayer game development in general. If you're a more advanced developer, feel free to skip sections so long as you feel confident in your understanding of what's going on.

## Repo

The source code of the 3D platformer can be located [here](https://github.com/hathora/3d-platformer). The repo's README file will guide you through running the game on your local machine, and there is an existing build of the game deployed to the web which can be sampled [here](https://3d-platformer.netlify.app/).

Upon completion of this tutorial, your game will look like this:

![A screenshot of the completed 3D platformer demo game, running fullscreen in the browser.](https://user-images.githubusercontent.com/7004280/213311928-18d0ed21-d309-4a30-8c7c-36cf0655d0f5.png)

## Bootstrapping the project

To quickly bootstrap a Hathora BuildKit boilerplate for our new project from which we can develop, `cd` into the folder where you keep all your projects and run the following:

```bash
npm init hathora-buildkit
```

This will prompt you to enter a name for your project. Here I'm simply calling mine "3d-platformer" but you can choose any name you see fit:

![A screenshot of the npm init hathora-buildkit running in a Macos terminal.](https://user-images.githubusercontent.com/7004280/213312721-56bf867c-7234-4ea4-8e47-959e7ff230a0.png)

Once the tool finishes building your project's file/folder structure, it will install all necessary dependencies via `npm`. Once the command completes, `cd` into the newly created project folder, then open a second CLI tab in the same folder.

Run the following in the first tab:

```bash
npm run server
```

And in the second tab, run:

```bash
npm run client
```

With both commands running simultaneously, open a window using your preferred web browser (I'll be using Google Chrome), and navigate to `http://localhost:5173`. If all is well, you should be greeted with the following page:

![A webpage client generated by npm init hathora-buildkit, indicating that our project was successfully bootstrapped.](https://user-images.githubusercontent.com/7004280/213313891-86709999-868c-4fc2-a0e7-f99d834797de.png)

A moment or so after loading the page, the "Message from server:" box should flash green and display "Hello Hathora!"

If you see this message, congrats! You've successfully established a client-server connection!

## Common files

It is a common practice when building games with Hathora BuildKit to create a `common` folder in the root of your project. This folder typically contains any and all files which are used within both the game's client and server code.

In this section we will do just that.

First off, start by creating the folder by running the following from your project's root:

```bash
mkdir common
```

With the folder created, we'll next add all the common files that we'll utilize for this game:

```bash
cd common
touch map.ts
touch messages.ts
touch package.json
touch types.ts
```

With the files created, we can finally open up our code editor and get our hands dirty! You're welcome to use any code editor you prefer, I will be using VSCode.

With the project open in your code editor, let's go through each file in the `common` directory and enter their code. Feel free to copy and paste directly from this article.

### `common/package.json`

```json
{
  "type": "module"
}
```

The `package.json` file here simply marks this folder as a module, meaning we can leverage ES6 `import` and `export` statements.

### `common/types.ts`

```ts
export type Direction = {
  x: number;
  y: number;
  z: number;
}

export type Position = {
  x: number;
  y: number;
  z: number;
};

export type Player = {
  id: string;
  position: Position;
  theta: number;
  grounded: boolean;
  animation: string;
};

export type GameState = {
  players: Player[];
};
```

This file exports the `type`s representative of our primary game entities and state.

### `common/messages.ts`

```ts
import { Direction, GameState } from "./types";

export enum ClientMessageType {
  SetDirection,
  SetTheta,
  Jump,
}

export enum ServerMessageType {
  StateUpdate,
}

export type ClientMessage = SetDirectionMessage | SetThetaMessage | JumpMessage;

export type SetDirectionMessage = {
  type: ClientMessageType.SetDirection;
  direction: Direction;
};

export type SetThetaMessage = {
  type: ClientMessageType.SetTheta;
  theta: number;
}

export type JumpMessage = {
  type: ClientMessageType.Jump;
};

export type ServerMessage = StateUpdateMessage;

export type StateUpdateMessage = {
  type: ServerMessageType.StateUpdate;
  state: GameState;
  ts: number;
};
```

This file is exports an `enum` and a handful of `type`s which represent the various packet messages alongside the arguments they expect that will be communicated between our game's server and clients.

### `common/map.ts`

```ts
export const map = [
  // Stair pillars
  {
    x: -9,
    y: 1,
    z: 10,
    w: 4,
    h: 2,
    d: 4
  },
  {
    x: -3,
    y: 1.5,
    z: 10,
    w: 4,
    h: 3,
    d: 4
  },
  {
    x: 3,
    y: 2,
    z: 10,
    w: 4,
    h: 4,
    d: 4
  },
  {
    x: 9,
    y: 2.5,
    z: 10,
    w: 4,
    h: 5,
    d: 4
  },

  // Floating platforms
  {
    x: 9,
    y: 5,
    z: 1,
    w: 4,
    h: 1,
    d: 8
  },
  {
    x: 3,
    y: 6,
    z: 1,
    w: 4,
    h: 1,
    d: 4
  },
  {
    x: 3,
    y: 7,
    z: -5,
    w: 4,
    h: 1,
    d: 4
  },
  {
    x: -3,
    y: 8,
    z: -5,
    w: 4,
    h: 1,
    d: 4
  },
  {
    x: -3,
    y: 9,
    z: 1,
    w: 4,
    h: 1,
    d: 4
  },
  {
    x: -3,
    y: 10,
    z: 7,
    w: 4,
    h: 1,
    d: 4
  }
];
```

This file exports an array of objects which will represent the brick pillars and platforms in our game's world. Each object has an `x`, `y`, and `z` coordinate to represent it's position in 3D space, alongside a `w` (width), `h` (height), and `d` (depth) property to represent it's size.

Note that the map's ground (grass-textured object shown in the screenshot previously) is *not* included in this array.

## Server dependencies

For the specific game we're building today, we will need a few additional dependencies for our server's code to work with. These dependencies are:

- [enable3d](https://www.npmjs.com/package/enable3d): The 3D framework we're using (which can be run in a headless mode, aka without a visual representation)
- [@enable3d/ammo-on-nodejs](https://www.npmjs.com/package/@enable3d/ammo-on-nodejs): The 3D physics engine utilized by enable3d
- [hash.js](https://www.npmjs.com/package/hash.js): A collection of hash functions in pure JavaScript (but *with* TypeScript bindings)

To install all additional dependencies, run the following from your project's root:

```bash
cd server
npm install enable3d @enable3d/ammo-on-nodejs hash.js
```

After the installation is complete, your `server/package.json` should be update to look something like this:

```json
{
  "type": "module",
  "dependencies": {
    "@enable3d/ammo-on-nodejs": "^0.25.3",
    "@hathora/server-sdk": "^0.5.1",
    "dotenv": "^16.0.3",
    "enable3d": "^0.25.3",
    "hash.js": "^1.1.7"
  },
  "devDependencies": {
    "@types/node": "^18.11.9"
  }
}
```

## Server code

This section will delve into the game's server code, all of which should be contained within the `server/server.ts` file from within our project's root. Open this file within your code editor, delete all the code currently residing in it, and we will begin composing the 3D platformer's custom server code!

### Imports and constant configuration

The first chunk of code we'll add will import everything required by our server, and specify configuration variables as constants. After finishing the rest of this tutorial, feel free to come back and mess around with these variables and observe the results!

```ts
// @ts-ignore
import _ammo from '@enable3d/ammo-on-nodejs/ammo/ammo.js';
import Enable3D from '@enable3d/ammo-on-nodejs';
import { register, Store, UserId, RoomId } from "@hathora/server-sdk";
import dotenv from "dotenv";
import hash from "hash.js";
import { Direction, GameState } from "../common/types";
import { ClientMessage, ClientMessageType, ServerMessage, ServerMessageType } from "../common/messages";
import { map } from '../common/map';

const { Physics, ServerClock, ExtendedObject3D } = Enable3D;

// Game constants
const PLAYER_MOVE_SPEED = 200;
const PLAYER_TURN_SPEED = 100;
const PLAYER_JUMP_FORCE = 5;
const RADIANS_45 = 0.785398;

// A type which defines the properties of a player used internally on the server (not sent to client)
type InternalPlayer = {
  id: UserId;
  body: Enable3D.ExtendedObject3D;
  direction: Direction;
  theta: number;
  grounded: boolean;
  animation: string;
};

// A type which represents the internal state of the server, containing:
//   - physics: our "physics" engine (detect-collisions library)
//   - players: an array containing all connected players to a room
type InternalState = {
  physics: Enable3D.Physics;
  platforms: Enable3D.ExtendedObject3D[];
  players: InternalPlayer[];
};

// A map which the server uses to contain all room's InternalState instances
const rooms: Map<RoomId, InternalState> = new Map();
```

### The server store

Now let's append our server's `store` object. The `store` contains specific functionality consumed by Hathora BuildKit and contains much of our game's core logic.

```ts
// ...
// Create an object to represent our Store
const store: Store = {
  // newState is called when a user requests a new room, this is a good place to handle any world initialization
  newState(roomId: bigint, userId: string): void {
    // const clock = new ServerClock();

    // clock.onTick(delta => this.update(delta));

    const physics = new Physics();
    let platforms: Enable3D.ExtendedObject3D[] = [];

    // Create ground & platforms
    platforms.push(physics.add.box({
      name: 'ground',
      width: 40,
      depth: 40,
      collisionFlags: 2,
      mass: 0
    }));

    map.forEach((platform, i) => {
      platforms.push(physics.add.box({
        name: `ground_${i}`,
        x: platform.x,
        y: platform.y,
        z: platform.z,
        width: platform.w,
        height: platform.h,
        depth: platform.d,
        collisionFlags: 2,
        mass: 0
      }));
    });

    rooms.set(roomId, {
      physics,
      platforms,
      players: []
    });
  },

  // subscribeUser is called when a new user enters a room, it's an ideal place to do any player-specific initialization steps
  subscribeUser(roomId: bigint, userId: string): void {
    // Make sure the room exists
    if (!rooms.has(roomId)) {
      return;
    }
    const game = rooms.get(roomId)!;

    // Make sure the player hasn't already spawned
    if (!game.players.some((player) => player.id === userId)) {
      // Then create a physics body (box, for now) for the player
      const body = game.physics.add.box({ name: `player_${userId}`, y: 5 });
      body.scale.set(0.0005, 0.0005, 0.0005);
      body.body.setAngularFactor(0, 0, 0); // prevent player's body from rotating

      const groundSensor = new ExtendedObject3D();
      groundSensor.position.setY(5 - 1 - 0.0005);
      game.physics.add.existing(groundSensor, {
        mass: 1e-8,
        shape: 'box',
        width: 0.2,
        height: 0.2,
        depth: 0.2 
      });
      groundSensor.body.setCollisionFlags(4);
      game.physics.add.constraints.lock(body.body, groundSensor.body);

      groundSensor.body.on.collision((object, e) => {
        if (/ground/.test(object.name)) {
          const collidingPlayer = game.players.find((p) => p.id === userId);
          
          if (collidingPlayer) {
            if (e !== 'end') {
              collidingPlayer.grounded = true;
            }
            else {
              collidingPlayer.grounded = false;
            }
          }
        }
      });

      game.players.push({
        id: userId,
        body,
        direction: { x: 0, y: 0, z: 0},
        theta: 0,
        grounded: false,
        animation: 'Falling Idle'
      });
    }
  },

  // unsubscribeUser is called when a user disconnects from a room, and is the place where you'd want to do any player-cleanup
  unsubscribeUser(roomId: bigint, userId: string): void {
    // Make sure the room exists
    if (!rooms.has(roomId)) {
      return;
    }
    
    const game = rooms.get(roomId)!;
    const idx = game.players.findIndex((player) => player.id === userId);

    // Remove the player's physics body
    const {body} = game.players[idx];
    game.physics.destroy(body);
    
    // Remove the player from the room's state
    if (idx >= 0) {
      game.players.splice(idx, 1);
    }
  },

  // onMessage is an integral part of your game's server. It is responsible for reading messages sent from the clients and handling them accordingly, this is where your game's event-based logic should live
  onMessage(roomId: bigint, userId: string, data: ArrayBufferView): void {
    if (!rooms.has(roomId)) {
      return;
    }

    // Get the player, or return out of the function if they don't exist
    const game = rooms.get(roomId)!;
    const player = game.players.find((player) => player.id === userId);
    if (player === undefined) {
      return;
    }

    // Parse out the data string being sent from the client
    const dataStr = Buffer.from(data.buffer, data.byteOffset, data.byteLength).toString("utf8");
    const message: ClientMessage = JSON.parse(dataStr);

    // Handle the various message types, specific to this game
    if (message.type === ClientMessageType.SetDirection) {
      player.direction = message.direction;
    }
    else if (message.type === ClientMessageType.SetTheta) {
      player.theta = message.theta;
    }
    else if (message.type === ClientMessageType.Jump) {
      if (player.grounded) {
        player.body.body.transform();
        player.body.body.setVelocityY(PLAYER_JUMP_FORCE);
      }
    }
  },
};
```

### Connecting to the coordinator, the update loop, and syncing state with clients

This is the final piece of code required by our server. It will connect our server to the Hathora coordinator (which is responsible for load balancing, authentication and a lot more) and provide it with our game's store object which we defined in the previous step. It then initializes the ammo 3D physics engine, and runs our game's update loop and broadcasts the state to all connected clients on tick. The functions which define our game's update loop and broadcasting logic follow.

```ts
// ...
// Load our environment variables into process.env
dotenv.config();
if (process.env.APP_SECRET === undefined) {
  throw new Error("APP_SECRET not set");
}

// Connect to the Hathora coordinator
const coordinator = await register({
  coordinatorHost: process.env.COORDINATOR_HOST,
  appSecret: process.env.APP_SECRET,
  authInfo: { anonymous: { separator: "-" } },
  store,
});

const { host, storeId } = coordinator;
console.log(`Connected to coordinator at ${host} with storeId ${storeId}`);

_ammo().then((ammo: any) => {
  globalThis.Ammo = ammo;

  const clock = new ServerClock();

  clock.onTick(delta => {
    rooms.forEach((room, roomId) => {
      // Tick each room
      updateRoom(room, delta);

      // Send the state updates to each client connected to that room
      broadcastStateUpdate(roomId);
    });
  });
});

function updateRoom(room: InternalState, delta: number) {
  // Move each player with a direction set and apply gravity
  room.players.forEach((player) => {
    player.body.body.transform();

    // Forward / backward movement
    const {theta} = player;
    const x = Math.sin(theta + (RADIANS_45 * player.direction.x)) * PLAYER_MOVE_SPEED * player.direction.z * delta;
    // const x = PLAYER_MOVE_SPEED * player.direction.z * delta;
    // const x = player.body.body.velocity.x;
    const y = player.body.body.velocity.y;
    const z = Math.cos(theta + (RADIANS_45 * player.direction.x)) * PLAYER_MOVE_SPEED * player.direction.z * delta;
    // const z = PLAYER_MOVE_SPEED * player.direction.z * delta;

    player.body.body.setVelocity(x, y, z);

    if (player.grounded) {
      if (player.direction.z === 1) {
        player.animation = 'Slow Run';
      }
      else if (player.direction.z === -1) {
        player.animation = 'Running Backward';
      }
      else {
        player.animation = 'Idle';
      }
    }
    else {
      player.animation = 'Falling Idle';
    }

    player.body.body.refresh();
  });

  room.physics.update(delta * 1000);
}

function broadcastStateUpdate(roomId: RoomId) {
  const game = rooms.get(roomId)!;
  const subscribers = coordinator.getSubscribers(roomId);
  const now = Date.now();
  // Map properties in the game's state which the clients need to know about to render the game
  const state: GameState = {
    players: game.players.map((player) => ({
      id: player.id,
      position: {
        x: player.body.position.x,
        y: player.body.position.y,
        z: player.body.position.z,
      },
      theta: player.theta,
      grounded: player.grounded,
      animation: player.animation
    }))
  };

  // Send the state update to each connected client
  subscribers.forEach((userId) => {
    const msg: ServerMessage = {
      type: ServerMessageType.StateUpdate,
      state,
      ts: now,
    };
    coordinator.sendMessage(roomId, userId, Buffer.from(JSON.stringify(msg), "utf8"));
  });
}
```

With that code appended, our `server.ts` file is complete. Congrats! You are officially halfway through building a multiplayer 3D platformer! The next section will walk you through the process of building this game's client, responsible for rendering logic and sending user input to the server.

## Client dependencies

As with this game's server code, some additional dependencies are required by our game's client in order for our code to function.

The clientside dependencies we will be consuming are:

- [enable3d](https://www.npmjs.com/package/enable3d): The same 3D framework we're using on the server, but we will use it here for visuals.
- [three](https://www.npmjs.com/package/three): A popular 3D JavaScript library which we will integrate with `enable3d`.
- [interpolation-buffer](https://www.npmjs.com/package/interpolation-buffer): A utility for implementing linear interpolation into our game's client.
- [hash.js](https://www.npmjs.com/package/hash.js): The same collection of hashing functions we installed on our server.

To install this game's clientside dependencies, run the following from the project's root folder:

```bash
cd client
npm install enable3d three interpolation-buffer hash.js
```

After the module installation completes, your `client` folder's `package.json` file should look something like this:

```json
{
  "name": "client2",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview"
  },
  "devDependencies": {
    "typescript": "^4.9.3",
    "vite": "^4.0.0"
  },
  "dependencies": {
    "@hathora/client-sdk": "^0.0.7",
    "enable3d": "^0.25.3",
    "hash.js": "^1.1.7",
    "interpolation-buffer": "^1.2.5",
    "three": "^0.144.0"
  }
}
```

## Client code

### Static assets

First things first, let's make sure we have all the assets which our clientside code will draw on to render the game.

This will primarily consist of 3D models and image textures / normal maps.

First we'll create the folder structure:

```bash
cd client/public
mkdir textures
mkdir models
mkdir models/lewis
```

Next, navigate to each of the following links and download each asset into it's labelled folder:

- [client/public/favicon.png](https://raw.githubusercontent.com/hathora/3d-platformer/develop/client/public/favicon.png) *(Feel free to replace with your own favicon!)*
- [client/public/logo.png](https://raw.githubusercontent.com/hathora/3d-platformer/develop/client/public/logo.png) *(Feel free to replace with your own logo!)*
- [client/public/textures/Ground037_1K_Color.jpg](https://raw.githubusercontent.com/hathora/3d-platformer/develop/client/public/textures/Ground037_1K_Color.jpg)
- [client/public/textures/Ground037_1K_NormalGL.jpg](https://raw.githubusercontent.com/hathora/3d-platformer/develop/client/public/textures/Ground037_1K_NormalGL.jpg)
- [client/public/textures/PavingStones122_1K_Color.jpg](https://raw.githubusercontent.com/hathora/3d-platformer/develop/client/public/textures/PavingStones122_1K_Color.jpg)
- [client/public/textures/PavingStones122_1K_NormalGL.jpg](https://raw.githubusercontent.com/hathora/3d-platformer/develop/client/public/textures/PavingStones122_1K_NormalGL.jpg)
- [client/public/models/lewis/Idle.fbx](https://github.com/hathora/3d-platformer/blob/develop/client/public/models/lewis/Idle.fbx?raw=true)
- [client/public/models/lewis/unskinned/Falling Idle.fbx](https://github.com/hathora/3d-platformer/blob/develop/client/public/models/lewis/unskinned/Falling%20Idle.fbx?raw=true)
- [client/public/models/lewis/unskinned/Running Backward.fbx](https://github.com/hathora/3d-platformer/blob/develop/client/public/models/lewis/unskinned/Running%20Backward.fbx?raw=true)
- [client/public/models/lewis/unskinned/Slow Run.fbx](https://github.com/hathora/3d-platformer/blob/develop/client/public/models/lewis/unskinned/Slow%20Run.fbx?raw=true)

With all our assets downloaded locally and placed in the correct locations, we can now proceed with our client code.

> **Important note:** Depending on your browser / OS, saving `.jpg` images may default to `.jpeg`. If this happens, simply rename them to use the `.jpg` extension.

### HTML markup

First things first, we're going to modify our `client/index.html` file, removing the boilerplate code generated by `npm init hathora-buildkit` with the following:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hathora 3D Platformer</title>
  </head>
  <body>
    <div class="preloader">
      <img src="/logo.png" alt="Hathora" />
      
      <div class="preloader__bar">
        <div class="preloader__bar-inner"></div>
      </div>
    </div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>
```

### Connection helper

Next we're going to implement a connection helper class, which will ease coding our Hathora client-server connection later on. Create the file `client/src/connection.ts` and add the following code:

```ts
import { HathoraClient } from "@hathora/client-sdk";
import { HathoraTransport, TransportType } from "@hathora/client-sdk/lib/transport";

import { ClientMessage, ServerMessage } from "../../common/messages";

export type UpdateListener = (update: ServerMessage) => void;

// A class representing a connection to our server room
export class RoomConnection {
  private encoder = new TextEncoder();
  private decoder = new TextDecoder();
  private connection: HathoraTransport | undefined;
  private listeners: UpdateListener[] = [];

  public constructor(private client: HathoraClient, public token: string, public roomId: string) {}

  public async connect() {
    this.connection = await this.client.connect(
      this.token,
      this.roomId,
      (msg) => this.handleMessage(msg),
      (err) => this.handleClose(err),
      TransportType.WebSocket
    );
  }

  public addListener(listener: UpdateListener) {
    this.listeners.push(listener);
  }

  public sendMessage(msg: ClientMessage) {
    this.connection?.write(this.encoder.encode(JSON.stringify(msg)));
  }

  public disconnect() {
    this.connection?.disconnect();
    this.listeners = [];
  }

  private handleMessage(data: ArrayBuffer) {
    const msg: ServerMessage = JSON.parse(this.decoder.decode(data));
    this.listeners.forEach((listener) => listener(msg));
  }

  private handleClose(err: { code: number; reason: string }) {
    console.error("close", err);
  }
}
```

### DOM styling

The next file we'll modify is `client/src/style.css`. Strip out the boilerplate generated stylesheets and replace with the following CSS which will mainly add some nice styling and transitions to our preloader bar (we encourage you to play around with these styles).

The CSS is as follows:

```css
html,
body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  background-color: #222;
}

canvas {
  display: block;
}

.preloader {
  z-index: 10;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background-color: rgba(0, 0, 0, 0.5);

  opacity: 1;
  visibility: visible;
  transition: opacity 0.55, visibility 0.55;
}

.preloader img {
  margin-bottom: 64px;
}

.preloader.off {
  opacity: 0;
  visibility: hidden;
}

.preloader__bar {
  width: 65%;
  height: 8px;
  display: flex;
  flex-direction: row;
  justify-content: flex-start;
  align-items: center;
  padding: 2px;
  border: solid 1px #FFF;
  border-radius: 5px;
  background-color: transparent;
  overflow: hidden;

  transition: transform 0.55;
}

.preloader.off .preloader__bar {
  transform: translateY(30px);
}

.preloader__bar-inner {
  width: 0%;
  height: 100%;
  background-color: #FFF;

  transition: width 0.35s;
}
```

### Imports and Hathora client definition

Now it's time to begin working on our `client/src/main.ts` file. This file is the heart of our clientside implementation. We will start by simply importing all of our dependencies and defining the Hathora client instance.

Open `client/src/main.ts` and replace the boilerplate code with the following:

```ts
import './style.css';
import { Project, Scene3D, ExtendedObject3D, THREE, ThirdPersonControls, PointerLock, PointerDrag } from "enable3d";
import { HathoraClient } from "@hathora/client-sdk";
import { RoomConnection } from "./connection";
import { InterpolationBuffer } from "interpolation-buffer";
import { Direction, GameState, Player } from "../../common/types";
import { ClientMessageType } from "../../common/messages";
import * as SkeletonUtils from 'three/examples/jsm/utils/SkeletonUtils';
import { map } from '../../common/map';
import { MeshPhongMaterial } from 'three';

const client = new HathoraClient(process.env.APP_ID as string, process.env.COORDINATOR_HOST);
```

### The PlatformerScene class

Next we will define the `PlatformerScene` class, which contains the majority of our clientside logic.

Append the following to `client/src/main.ts`:

```ts
class PlatformerScene extends Scene3D {
  box: any;
  player!: ExtendedObject3D;
  stateBuffer: any;
  playerModel!: THREE.Group;
  playerAnims: Map<string, THREE.AnimationClip> = new Map();
  players: Map<string, ExtendedObject3D> = new Map();
  controls!: ThirdPersonControls;
  currentUserId!: string;
  prevDirection!: Direction;
  keys: Set<string> = new Set();
  connection!: RoomConnection;
  prevTheta: number = 0;
  preloaderContainer!: HTMLDivElement;
  preloaderBar!: HTMLDivElement;

  constructor() {
    super({
      key: 'PlatformerScene'
    });
  }

  async init() {
    this.renderer.setPixelRatio(1);
    this.renderer.setSize(window.innerWidth, window.innerHeight);

    this.load.preload('texture-grass', '/textures/Ground037_1K_Color.jpg');
    this.load.preload('normal-grass', '/textures/Ground037_1K_NormalGL.jpg');
    this.load.preload('texture-brick', '/textures/PavingStones122_1K_Color.jpg');
    this.load.preload('normal-brick', '/textures/PavingStones122_1K_NormalGL.jpg');
  }

  bindPreloaderDOM() {
    this.preloaderContainer = document.querySelector('.preloader') as HTMLDivElement;
    this.preloaderBar = this.preloaderContainer.querySelector('.preloader__bar-inner') as HTMLDivElement;
  }

  setPreloaderPercentage(p: number) {
    if (p === 1) {
      this.preloaderContainer.classList.add('off');
    }

    this.preloaderBar.style.width = `${p*100}%`;
  }


  async create() {
    this.warpSpeed('-ground', '-orbitControls', '-lookAtCenter', '-camera');

    this.bindPreloaderDOM();

    this.setPreloaderPercentage(0);

    // Initialize Hathora server connection
    const token = await getToken();

    this.setPreloaderPercentage(0.1);

    // Once we have a token, we can get our roomId
    const roomId = await getRoomId(token);

    this.setPreloaderPercentage(0.2);

    // With a roomId, we can establish a connection to the room on server
    this.connection = new RoomConnection(client, token, roomId);
    await this.connection.connect();

    this.setPreloaderPercentage(0.3);

    // Save the current user's ID, so we know who to follow with the camera
    const currentUser = HathoraClient.getUserFromToken(token);
    this.currentUserId = currentUser.id;

    // Begin linear interpolation for player positions
    this.connection.addListener(({ state, ts }) => {
      // Start enqueuing state updates
      if (this.stateBuffer === undefined) {
        this.stateBuffer = new InterpolationBuffer(state, 50, lerp);
      }
      else {
        this.stateBuffer.enqueue(state, [], ts);
      }
    });

    // Parse Lewis' animations
    const animations = [
      'Slow Run',
      'Running Backward',
      'Falling Idle'
    ];

    let load = 0.3;

    for (let animKey of animations) {
      const anim = await this.load.fbx(`/models/lewis/unskinned/${animKey}.fbx`);

      this.playerAnims.set(animKey, anim.animations[0]);
      
      load += 0.15;
      this.setPreloaderPercentage(load);
    }

    // Load model
    this.playerModel = await this.load.fbx('/models/lewis/Idle.fbx');
    this.playerAnims.set('Idle', this.playerModel.animations[0]);

    this.setPreloaderPercentage(0.9);

    // Render the ground
    const groundNormal = await this.load.texture('normal-grass');
    const groundTexture = await this.load.texture('texture-grass');

    this.setPreloaderPercentage(0.95);

    groundNormal.wrapS = THREE.RepeatWrapping;
    groundNormal.wrapT = THREE.RepeatWrapping;
    groundNormal.repeat.set(4, 4);

    groundTexture.wrapS = THREE.RepeatWrapping;
    groundTexture.wrapT = THREE.RepeatWrapping;
    groundTexture.repeat.set(4, 4);

    this.add.box({ width: 40, depth: 40 }, {
      phong: {
        map: groundTexture,
        normalMap: groundNormal,
        normalScale: new THREE.Vector2(4, 4)
      }
    });

    // Render the map platforms
    const brickTexture = await this.load.texture('texture-brick');
    const brickNormal = await this.load.texture('normal-brick');

    map.forEach(async (platform) => {
      this.add.box(
        {
          x: platform.x,
          y: platform.y,
          z: platform.z,
          width: platform.w,
          height: platform.h,
          depth: platform.d
        },
        {
          phong: {
            map: brickTexture,
            normalMap: brickNormal,
            normalScale: new THREE.Vector2(8, 8),
            transparent: true
          }
        }
      );
    });
    
    // Setup player keyboard input
    this.prevDirection = { x: 0, y: 0, z: 0 };
    this.bindKeyboardEvents();

    this.setPreloaderPercentage(1);
  }

  update(time: number) {
    // If the stateBuffer hasn't been defined, skip this update tick
    if (this.stateBuffer === undefined) {
      return;
    }

    // Get current interpolated state from buffer
    const { state } = this.stateBuffer.getInterpolatedState(Date.now());

    // Spawn or update our player models
    this.syncModels(state, time);

    // Keep camera controls in sync
    this.controls.update(0, 0);

    // Send any keyboard input to the server
    this.sendKeyboardInput();

    // Send player rotational data
    this.sendPlayerTheta();
  }

  bindKeyboardEvents() {
    window.addEventListener('keydown', (e: KeyboardEvent) => {
      this.keys.add(e.key.toLowerCase());
    });
    window.addEventListener('keyup', (e: KeyboardEvent) => {
      this.keys.delete(e.key.toLowerCase());
    });
  }

  sendKeyboardInput() {
    let direction: Direction = {
      x: 0,
      y: 0,
      z: 0
    };
  
    if (this.keys.has('w')) {
      direction.z = 1;
    }
    else if (this.keys.has('s')) {
      direction.z = -1;
    }
  
    if (this.keys.has('a')) {
      direction.x = 1;
    }
    else if (this.keys.has('d')) {
      direction.x = -1;
    }
  
    if (this.keys.has(' ')) {
      this.connection.sendMessage({ type: ClientMessageType.Jump });
    }
  
    if (direction.x !== this.prevDirection.x || direction.y !== this.prevDirection.y || direction.z !== this.prevDirection.z) {
      this.prevDirection = direction;
      this.connection.sendMessage({ type: ClientMessageType.SetDirection, direction });
    }
  }

  sendPlayerTheta() {
    if (this.player) {
      const v3 = new THREE.Vector3();
  
      const rotation = this.camera.getWorldDirection(v3);
      const theta = Math.atan2(rotation.x, rotation.z);

      if (theta !== this.prevTheta) {
        this.connection.sendMessage({ type: ClientMessageType.SetTheta, theta });
        this.prevTheta = theta;
      }
    }
  }

  buildPlayer() {
    // Create the object for our player
    const player = new ExtendedObject3D();

    // Clone our loaded player model
    // const model = this.playerModel.clone();
    const model = SkeletonUtils.clone(this.playerModel);

    // Lower it's scale
    model.scale.set(0.01, 0.01, 0.01);

    // Enable shadows on all mesh
    model.traverse((object: any) => {
      if (object.isMesh) {
        object.castShadow = true;
        object.receiveShadow = true;

        object.material.forEach((material: MeshPhongMaterial) => {
          material.color.setRGB(2, 2, 2);
        });
      }
    });

    // Add the model to the object
    player.add(model);

    // Add loaded animations
    const animations = [
      'Idle',
      'Slow Run',
      'Running Backward',
      'Falling Idle'
    ];

    for (let animKey of animations) {
      const anim = this.playerAnims.get(animKey);

      if (anim) {
        player.anims.add(
          animKey,
          anim
        );
      }
    }

    // Return our fresh player!
    return player;
  }

  syncModels(state: any, time: number) {
    const {players} = state;

    // Add or update player models
    players.forEach((player: Player) => {
      if (this.players.has(player.id)) {
        const playerObject = this.players.get(player.id);

        // Position player based on server
        playerObject?.position.set(player.position.x, player.position.y - 0.5, player.position.z);

        // Set rotation based on server theta
        playerObject?.rotation.set(0, player.theta, 0);

        // Handle animation syncing
        playerObject?.anims.play(player.animation, 600);

        playerObject?.animationMixer.update(time);
      }
      else {
        const playerObject = this.buildPlayer();

        playerObject.anims.play('Falling Idle');
        
        this.scene.add(playerObject);
        this.players.set(player.id, playerObject);

        // If this player belongs to current client, setup controls
        if (this.currentUserId === player.id) {
          this.controls = new ThirdPersonControls(this.camera, playerObject, {
            offset: new THREE.Vector3(0, 1, 0),
            targetRadius: 6
          });

          this.controls.theta = 90;

          const pl = new PointerLock(this.canvas);
          const pd = new PointerDrag(this.canvas);

          pd.onMove((delta) => {
            if (pl.isLocked()) {
              this.controls.update(delta.x * 2, delta.y * 2);
            }
          });

          this.player = playerObject;
        }
      }
    });

    // Remove any destroyed players
    this.players.forEach((playerObject, id) => {
      const playerExistsInState = (players.findIndex((p: Player) => p.id === id) > -1);

      if (!playerExistsInState) {
        playerObject.removeFromParent();
      }
    });
  }
}
```

Let's break down the key functions at play in this class:

> constructor

Much like a scene's constructor in those familiar with PhaserJS games, we simply use it here to declare a unique key for our scene: `"PlatformerScene"` in our case.

> init

This is a function we are overriding from the base `Scene3D` class. We're calling a couple functions on the inherited renderer object (pixel ratio and canvas size). Then after that we're using Enable3D's `preload` function to load in some regular images and normal maps to apply to our map objects later.

> bindPreloaderDOM

This is the first custom function we're defining, simply used to bind our preloader `<div>` element which we described earlier in our markup.

> setPreloaderPercentage

This function takes a number between 0 and 1 as a percentage, and applies the appropriate styling and class modifications to our preloader element such that it updates to load percentage changes.

> create

Another function we're overriding from `Scene3D`, `create` is used to setup our scene. It starts by calling `Scene3D`'s `warpSpeed` function, without a ground, orbit controls, look at center, and a camera (as we're handling these manually).

After that we get a `token` and `roomId` using Hathora, and establish our new `RoomConnection`. We store the current user's ID for later use and add a listener to our newly definied connection, defining then enqueuing state patches to our state `InterpolationBuffer`.

The next step this function handles is loading each of the unskinned animation FBX files and storing them in our `playerAnims` map. After loading each of the unskinned animation files, it loads the *skinned* model file.

Finally, using the loaded image textures, normal maps, and map data loaded from our `common/map.ts` file the `create` function renders our game world's map.

> update

Our scene's `update` function is the method which will be called on every tick in game-time. It starts by ensuring our `stateBuffer` property is defined, then gets the latest state patch and uses it alongside functions (defined below) responsible for syncing our player models and camera controls, sending keyboard input to the server for processing, as well as sending the player's theta value in 3D space.

> bindKeyboardEvents

Called earlier in our `create` method, this function is simply responsible for binding `'keydown'` and `'keyup'` listeners, which add and remove keys from a set representitive of the keyboard buttons currently being pressed down.

> sendKeyboardInput

This function is responsible for creating a 3D directional vector based on current keyboard input, then sending that vector to the server for movement processing.

The function will also send an event to the server if the spacebar is being pressed to indicate that the player should jump.

> sendPlayerTheta

This function first ensures that there is a current player object, and provided that there is, will determine it's `theta`. The previous tick's `theta` is stored and diffed against the current tick. If they are different, it will send an update message to the server.

> buildPlayer

The `buildPlayer` function is responsible for cloning a model for each player that connects to the game, applying each of the loaded FBX animations to it, then returning it for further use.

> syncModels

Finally, our `syncModels` function accepts state patches and time values as it's arguments, and mutates our player map to handle:

- New player connections
- Existing player updates
- Player disconnects

Such that the visual state of our 3D scene will represent our game's server state accordingly.

### Helpers and lerping functions

The final thing we need to append to `main.ts` is our helper functions for setting up our Hathora connection and the functions we feed into our `InterpolationBuffer` to handle our state's linear interpolation:

```ts
// The getToken function first checks sessionStorage to see if there is an existing token, and if there is returns it. If not, it logs the user into a new session and updates the sessionStorage key.
async function getToken(): Promise<string> {
  const maybeToken = sessionStorage.getItem("3d-platformer-token");
  if (maybeToken !== null) {
    return maybeToken;
  }

  const token = await client.loginAnonymous();
  sessionStorage.setItem("3d-platformer-token", token);
  return token;
}

// getRoomId will first check if the location's pathname contains the roomId, and will return it if it does, otherwise it will request one from the HathoraClient instance we defined earlier.
async function getRoomId(token: string): Promise<string> {
  if (location.pathname.length > 1) {
    return location.pathname.split("/").pop()!;
  }
  
  const roomId = await client.create(token, new Uint8Array());
  history.pushState({}, "", `/${roomId}`);
  return roomId;
}

function lerp(from: GameState, to: GameState, pctElapsed: number): GameState {
  return {
    players: to.players.map((toPlayer) => {
      const fromPlayer = from.players.find((p) => p.id === toPlayer.id);
      return fromPlayer !== undefined ? lerpPlayer(fromPlayer, toPlayer, pctElapsed) : toPlayer;
    })
  };
}

function lerpPlayer(from: Player, to: Player, pctElapsed: number): Player {
  return {
    id: to.id,
    position: {
      x: from.position.x + (to.position.x - from.position.x) * pctElapsed,
      y: from.position.y + (to.position.y - from.position.y) * pctElapsed,
      z: from.position.z + (to.position.z - from.position.z) * pctElapsed,
    },
    theta: from.theta + (to.theta - from.theta) * pctElapsed,
    animation: to.animation,
    grounded: to.grounded
  };
}

const config = {
  scenes: [
    PlatformerScene
  ]
};

new Project(config);
```

And with that, we're done! Run the following commands from two separate tabs in the project's root:

```bash
npm run server
# then, in another tab...
npm run client
```

And open `http://localhost:5173` in a browser and take your fresh multiplayer 3D platformer game for a spin! ðŸ¥³