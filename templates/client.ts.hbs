import WebSocket from "isomorphic-ws";
import axios from "axios";
import { decode } from "@msgpack/msgpack";
import {
  PlayerName,
  {{userState}},
  {{#each methods}}
  {{makeRequestName @key}},
  {{/each}}
} from "./types";

export type StateId = string;

export class RtagClient {
  private callbacks: Record<string, (error?: string) => void> = {};

  private constructor(private socket: WebSocket) {}

  public static async registerUser(username: PlayerName): Promise<string> {
    const res = await axios.post("/register", { playerName: username });
    return res.data.token;
  }

  public static async createState(token: string, request: {{makeRequestName initialize}}): Promise<StateId> {
    const res = await axios.post("/new", request, { headers: { Authorization: "Bearer " + token } });
    return res.data.stateId;
  }

  public static connect(
    host: string,
    token: string,
    stateId: StateId,
    onStateChange: (state: {{userState}}) => void
  ): Promise<RtagClient> {
    return new Promise((resolve) => {
      const socket = new WebSocket(`ws://${host}/${stateId}`);
      socket.binaryType = "arraybuffer";
      const client = new RtagClient(socket);
      socket.onopen = () => {
        socket.send(token);
        resolve(client);
      };
      socket.onmessage = ({ data }) => {
        const message: any = decode(data as ArrayBuffer);
        if (message.type === "response") {
          client.callbacks[message.msgId](message.error);
          delete client.callbacks[message.msgId];
        } else if (message.type === "state") {
          onStateChange(message.state);
        } else {
          console.error("Unknown message type: " + message.type);
        }
      };
    });
  }

  {{#each methods}}
  {{#if (ne @key ../initialize)}}
  public {{@key}}(request: {{makeRequestName @key}}, cb: (error?: string) => void): void {
    const msgId = Math.random().toString(36).substring(2);
    this.callbacks[msgId] = cb;
    this.socket.send(JSON.stringify({ method: "{{@key}}", msgId, args: request }));
  }

  {{/if}}
  {{/each}}
  public disconnect(): void {
    this.socket.close();
  }
}
