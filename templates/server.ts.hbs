import WebSocket from "ws";
import express from "express";
import jwt from "jsonwebtoken";
import onChange from "on-change";
import { Encoder } from "@msgpack/msgpack";
import Bundler from "parcel-bundler";
import { reload } from "import-reload";
import * as http from "http";
import * as path from "path";
import { {{userData}} } from "./types";

const app = express();
const server = http.createServer(app);
const wss = new WebSocket.Server({ noServer: true });
const encoder = new Encoder();
const bundler = new Bundler(path.join(__dirname, "{{appEntryPath}}"), {
  cache: false,
});

interface Client {
  userData: {{userData}};
  socket: WebSocket;
  alive: boolean;
}

interface UpdateRequest {
  method: string;
  msgId: string;
  args: any;
}

async function main() {
  const impl = await reload(
    () => import("../impl"),
    (Impl) => new Impl.Impl()
  );

  type State = ReturnType<typeof impl.{{initialize}}>;
  const states: Map<string, State> = new Map();
  const changedStates: Map<string, State> = new Map();
  const connections: Map<string, Set<Client>> = new Map();

  setInterval(() => {
    {{#if tick}}
    states.forEach(impl.onTick);
    {{/if}}
    changedStates.forEach((state, stateId) => {
      broadcastUpdates(stateId, state);
    });
    changedStates.clear();
  }, 50);

  app.use(express.json());
  app.post("/register", (req, res) => {
    const userData = req.body;
    const token = jwt.sign(userData, "secret");
    res.json({ token });
  });
  app.post("/new", (req, res) => {
    const token = req.headers.authorization!.split(" ")[1];
    const userData = jwt.verify(token, "secret") as {{userData}};
    const state = impl.{{initialize}}(userData, req.body);
    const stateId = Math.random().toString(36).substring(2);
    states.set(
      stateId,
      onChange(state, () => {
        changedStates.set(stateId, state);
      })
    );
    res.json({ stateId });
  });
  app.use(bundler.middleware());

  server.on("upgrade", (req, socket, head) => {
    const stateId = req.url.substring(1);
    const state = states.get(stateId);
    if (state == undefined) {
      socket.write("HTTP/1.1 404 Not Found\r\n\r\n");
      socket.destroy();
      return;
    }
    wss.handleUpgrade(req, socket, head, (ws) => {
      ws.once("message", (token) => {
        const userData = jwt.verify(token, "secret") as {{userData}};
        handleConnection(stateId, state, userData, ws);
      });
    });
  });

  function handleConnection(stateId: string, state: State, userData: {{userData}}, socket: WebSocket) {
    const client = { userData, socket, alive: true };
    addConnection(stateId, client);
    socket.on("close", () => {
      deleteConnection(stateId, client);
    });

    socket.send(encoder.encode({ type: "state", state: impl.getUserState(state, userData) }));
    socket.on("message", (data) => {
      const { method, msgId, args }: UpdateRequest = JSON.parse(data as string);
      const fn = impl[method as keyof typeof impl] as (state: State, userData: {{userData}}, args: any) => string | void;
      const error = fn(state, userData, args);
      if (error) {
        socket.send(encoder.encode({ type: "response", msgId, error }));
      } else {
        socket.send(encoder.encode({ type: "response", msgId }));
      }
    });
  }

  function addConnection(stateId: string, client: Client) {
    client.socket.on("pong", () => {
      client.alive = true;
    });
    if (!connections.has(stateId)) {
      connections.set(stateId, new Set([client]));
    } else {
      connections.get(stateId)!.add(client);
    }
  }

  function deleteConnection(stateId: string, client: Client) {
    connections.get(stateId)!.delete(client);
    if (connections.get(stateId)!.size === 0) {
      connections.delete(stateId);
    }
  }

  function broadcastUpdates(stateId: string, state: State) {
    connections.get(stateId)!.forEach(({ userData, socket }) => {
      socket.send(encoder.encode({ type: "state", state: impl.getUserState(state, userData) }));
    });
  }

  server.listen(3000, () => {
    console.log("listening on *:3000");
  });

  setInterval(() => {
    const deadClients: Map<Client, string> = new Map();
    connections.forEach((clients, stateId) => {
      clients.forEach((client) => {
        if (!client.alive) {
          deadClients.set(client, stateId);
        } else {
          client.alive = false;
          client.socket.ping(() => {});
        }
      });
    });
    deadClients.forEach((stateId, client) => {
      client.socket.terminate();
      deleteConnection(stateId, client);
    });
  }, 30000);
}

main();
