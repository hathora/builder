import WebSocket from "ws";
import express from "express";
import jwt from "jsonwebtoken";
import onChange from "on-change";
import { Encoder } from "@msgpack/msgpack";
import Bundler from "parcel-bundler";
import { reload } from "import-reload";
import * as http from "http";
import * as path from "path";

const app = express();
const server = http.createServer(app);
const wss = new WebSocket.Server({ noServer: true });
const encoder = new Encoder();
const bundler = new Bundler(path.join(__dirname, "index.html"), {
  cache: false,
});

interface Client {
  userData: any;
  socket: WebSocket;
  alive: boolean;
}

interface UpdateRequest {
  method: string;
  msgId: string;
  args: any;
}

const states: Map<string, any> = new Map();
const connections: Map<string, Set<Client>> = new Map();

async function main() {
  const impl = await reload(
    () => import("../impl"),
    (Impl) => new Impl.Impl()
  );

  {{#if tick}}
  setInterval(() => {
    states.forEach(impl.onTick);
  }, 50);

  {{/if}}
  app.use(express.json());
  app.post("/register", (req, res) => {
    const userData = req.body;
    const token = jwt.sign(userData, "secret");
    res.json({ token });
  });
  app.post("/new", (req, res) => {
    const token = req.headers.authorization!.split(" ")[1];
    const userData = jwt.verify(token, "secret");
    const state = impl.{{initialize}}(userData as any, req.body);
    const stateId = Math.random().toString(36).substring(2);
    states.set(
      stateId,
      onChange(state, () => {
        broadcastUpdates(stateId, state);
      })
    );
    res.json({ stateId });
  });
  app.use(bundler.middleware());

  server.on("upgrade", (req, socket, head) => {
    const stateId = req.url.substring(1);
    wss.handleUpgrade(req, socket, head, (ws) => {
      ws.once("message", (token) => {
        const userData = jwt.verify(token, "secret");
        handleConnection(stateId, userData, ws);
      });
    });
  });

  function handleConnection(stateId: string, userData: any, socket: WebSocket) {
    const client = { userData, socket, alive: true };
    addConnection(stateId, client);
    socket.on("close", () => {
      deleteConnection(stateId, client);
    });

    const state = states.get(stateId)!;
    socket.send(encoder.encode({ type: "state", state: impl.getUserState(state, userData) }));
    socket.on("message", (data) => {
      const { method, msgId, args }: UpdateRequest = JSON.parse(data as string);
      const error = impl[method as keyof typeof impl](state, userData, args) as string | void;
      if (error) {
        socket.send(encoder.encode({ type: "response", msgId, error }));
      } else {
        socket.send(encoder.encode({ type: "response", msgId }));
      }
    });
  }

  function addConnection(stateId: string, client: Client) {
    client.socket.on("pong", () => {
      client.alive = true;
    });
    if (!connections.has(stateId)) {
      connections.set(stateId, new Set([client]));
    } else {
      connections.get(stateId)!.add(client);
    }
  }

  function deleteConnection(stateId: string, client: Client) {
    connections.get(stateId)!.delete(client);
    if (connections.get(stateId)!.size === 0) {
      connections.delete(stateId);
    }
  }

  function broadcastUpdates(stateId: string, state: any) {
    connections.get(stateId)!.forEach(({ userData, socket }) => {
      socket.send(encoder.encode({ type: "state", state: impl.getUserState(state, userData) }));
    });
  }

  server.listen(3000, () => {
    console.log("listening on *:3000");
  });

  setInterval(() => {
    const deadClients: Map<Client, string> = new Map();
    connections.forEach((clients, stateId) => {
      clients.forEach((client) => {
        if (!client.alive) {
          deadClients.set(client, stateId);
        } else {
          client.alive = false;
          client.socket.ping(() => {});
        }
      });
    });
    deadClients.forEach((stateId, client) => {
      client.socket.terminate();
      deleteConnection(stateId, client);
    });
  }, 30000);
}

main();
