import WebSocket from "isomorphic-ws";
// @ts-ignore
import getRandomValues from "get-random-values";
import axios from "axios";
import jwtDecode from "jwt-decode";
import { Socket } from "net";
import { Reader, Writer } from "bin-serde";
import { UserData, Response, Method, COORDINATOR_HOST, MATCHMAKER_HOST } from "../../api/base";
import {
  decodeStateSnapshot,
  decodeStateUpdate,
  {{userState}} as UserState,
  IInitializeRequest,
  {{#each methods}}
  {{makeRequestName @key}},
  {{/each}}
} from "../../api/types";
import { ConnectionFailure, transformCoordinatorFailure } from "./failures";
import { computePatch } from "./patch";

export type StateId = string;
export type UpdateArgs = { stateId: StateId; state: UserState; updatedAt: number; events: string[] };
export type UpdateCallback = (updateArgs: UpdateArgs) => void;
export type ErrorCallback = (error: ConnectionFailure) => void;

export enum TransportType {
  WebSocket,
  TCP,
  UDP,
}

export class HathoraClient {
  public appId = "{{appId}}";

  public static getUserFromToken(token: string): UserData {
    return jwtDecode(token);
  }

{{#each auth}}
{{#if (eq @key "anonymous")}}
  public async loginAnonymous(): Promise<string> {
    const res = await axios.post(`https://${COORDINATOR_HOST}/${this.appId}/login/anonymous`);
    return res.data.token;
  }

{{else if (eq @key "google")}}
  public async loginGoogle(idToken: string): Promise<string> {
    const res = await axios.post(`https://${COORDINATOR_HOST}/${this.appId}/login/google`, { idToken });
    return res.data.token;
  }

{{/if}}
{{/each}}
  public async create(token: string, request: IInitializeRequest): Promise<string> {
    const res = await axios.post(
      `https://${COORDINATOR_HOST}/${this.appId}/create`,
      IInitializeRequest.encode(request).toBuffer(),
      { headers: { Authorization: token, "Content-Type": "application/octet-stream" } }
    );
    return res.data.stateId;
  }

  public async connect(
    token: string,
    stateId: StateId,
    transportType: TransportType = TransportType.WebSocket
  ): Promise<HathoraConnection> {
    switch (transportType) {
      case TransportType.WebSocket:
        return this.connectWebSocket(token, stateId);
      case TransportType.TCP:
        return this.connectTCP(token, stateId);
      case TransportType.UDP:
      // return this.connectUDP(token, stateId);
      default:
        throw new Error("Unknown transport type");
    }
  }

  public async connectWebSocket(token: string, stateId: StateId): Promise<HathoraConnection> {
    return new Promise((resolve, reject) => {
      const socket = new WebSocket(`wss://${COORDINATOR_HOST}/${this.appId}`);
      socket.binaryType = "arraybuffer";
      socket.onclose = (e) => reject(transformCoordinatorFailure(e));
      socket.onopen = () =>
        socket.send(
          new Writer()
            .writeUInt8(0)
            .writeString(token)
            .writeUInt64([...stateId].reduce((r, v) => r * 36n + BigInt(parseInt(v, 36)), 0n))
            .toBuffer()
        );
      socket.onmessage = ({ data }) => {
        const reader = new Reader(new Uint8Array(data as ArrayBuffer));
        const type = reader.readUInt8();
        if (type === 0) {
          resolve(new WebSocketHathoraConnection(stateId, decodeStateSnapshot(reader), socket));
        } else {
          reject("Unknown message type: " + type);
        }
      };
    });
  }

  public async connectTCP(token: string, stateId: StateId): Promise<HathoraConnection> {
    return new Promise((resolve, reject) => {
      const socket = new Socket();
      socket.connect(7148, COORDINATOR_HOST);
      socket.on("connect", () =>
        socket.write(
          new Writer()
            .writeUInt8(0)
            .writeString(token)
            .writeString(this.appId)
            .writeUInt64([...stateId].reduce((r, v) => r * 36n + BigInt(parseInt(v, 36)), 0n))
            .toBuffer()
        )
      );
      socket.once("data", (data: Buffer) => {
        const reader = new Reader(new Uint8Array(data as ArrayBuffer));
        const type = reader.readUInt8();
        if (type === 0) {
          resolve(new TCPHathoraConnection(stateId, decodeStateSnapshot(reader), socket));
        } else {
          reject("Unknown message type: " + type);
        }
      });
    });
  }

  public async findMatch(
    token: string,
    request: IInitializeRequest,
    numPlayers: number,
    onUpdate: (playersFound: number) => void
  ): Promise<string> {
    return new Promise<string>((resolve, reject) => {
      const socket = new WebSocket(`wss://${MATCHMAKER_HOST}/${this.appId}`);
      socket.binaryType = "arraybuffer";
      socket.onclose = reject;
      socket.onopen = () =>
        socket.send(
          new Writer()
            .writeString(token)
            .writeUVarint(numPlayers)
            .writeBuffer(IInitializeRequest.encode(request).toBuffer())
            .toBuffer()
        );
      socket.onmessage = ({ data }) => {
        const reader = new Reader(new Uint8Array(data as ArrayBuffer));
        const type = reader.readUInt8();
        if (type === 0) {
          onUpdate(reader.readUVarint());
        } else if (type === 1) {
          resolve(reader.readString());
        } else {
          console.error("Unknown message type", type);
        }
      };
    });
  }
}

export abstract class HathoraConnection {
  protected updateListeners: UpdateCallback[] = [];
  protected errorListeners: ErrorCallback[] = [];
  protected callbacks: Record<string, (response: Response) => void> = {};
  protected changedAt = 0;

  constructor(
    public stateId: StateId,
    public state: UserState,
    onUpdate?: UpdateCallback,
    onError?: ErrorCallback
  ) {
    if (onUpdate !== undefined) {
      this.onUpdate(onUpdate);
      onUpdate({ stateId, state: JSON.parse(JSON.stringify(this.state)), updatedAt: 0, events: [] });
    }
    if (onError !== undefined) {
      this.onError(onError);
    }
  }

  public onUpdate(listener: UpdateCallback) {
    this.updateListeners.push(listener);
  }

  public onError(listener: ErrorCallback) {
    this.errorListeners.push(listener);
  }

  public removeAllListeners() {
    this.updateListeners = [];
    this.errorListeners = [];
  }

  protected abstract callMethod(method: Method, request: Uint8Array): Promise<Response>;

  {{#each methods}}
  public {{@key}}(request: {{makeRequestName @key}}): Promise<Response> {
    return this.callMethod(Method.{{uppercase @key}}, {{makeRequestName @key}}.encode(request).toBuffer());
  }

  {{/each}}
}


export class TCPHathoraConnection extends HathoraConnection {
  constructor(public stateId: StateId, public state: UserState, private socket: Socket, onUpdate?: UpdateCallback, onError?: ErrorCallback) {
    super(stateId, state, onUpdate, onError);
    TCPHathoraConnection.readTCPData(socket, (data) => {
      const reader = new Reader(new Uint8Array(data as ArrayBuffer));
      const type = reader.readUInt8();

      if (type === 0) {
        this.state = decodeStateSnapshot(reader);
        this.changedAt = 0;
        this.updateListeners.forEach((listener) =>
          listener({ stateId, state: JSON.parse(JSON.stringify(this.state)), updatedAt: 0, events: [] })
        );
      } else if (type === 1) {
        const { stateDiff, changedAtDiff, responses, events } = decodeStateUpdate(reader);
        if (stateDiff !== undefined) {
          this.state = computePatch(this.state!, stateDiff);
        }
        this.changedAt += changedAtDiff;
        this.updateListeners.forEach((listener) =>
          listener({
            stateId,
            state: JSON.parse(JSON.stringify(this.state)),
            updatedAt: this.changedAt,
            events: events.map((e) => e.event),
          })
        );
        responses.forEach(({ msgId, response }) => {
          if (msgId in this.callbacks) {
            this.callbacks[msgId](response);
            delete this.callbacks[msgId];
          }
        });
      } else if (type === 2) {
        this.disconnect();
      } else if (type === 3) {
        TCPHathoraConnection.writeTCPData(socket, new Writer().writeUInt8(2).toBuffer());
      } else {
        console.error("Unknown message type", type);
      }
    });
    socket.on("close", (hadError) => {
      this.errorListeners.forEach((listener) =>
        listener(transformCoordinatorFailure({ code: 4000, reason: "Connection closed" }))
      );
    });
  }

  protected callMethod(method: Method, request: Uint8Array): Promise<Response> {
    return new Promise((resolve, reject) => {
      if (this.socket.readyState !== "open") {
        reject("Connection not open");
      } else {
        const msgId: Uint8Array = getRandomValues(new Uint8Array(4));
        TCPHathoraConnection.writeTCPData(
          this.socket,
          new Uint8Array([...new Uint8Array([method]), ...msgId, ...request])
        );
        this.callbacks[new DataView(msgId.buffer).getUint32(0)] = resolve;
      }
    });
  }

  private static readTCPData(socket: Socket, onData: (data: Buffer) => void) {
    let buf = Buffer.alloc(0);
    socket.on("data", (data) => {
      buf = Buffer.concat([buf, data]);
      while (buf.length >= 4) {
        const bufLen = buf.readUInt32BE();
        if (buf.length < 4 + bufLen) {
          return;
        }
        onData(buf.slice(4, 4 + bufLen));
        buf = buf.slice(4 + bufLen);
      }
    });
  }

  private static writeTCPData(socket: Socket, data: Uint8Array) {
    socket.write(new Writer().writeUInt32(data.length).writeBuffer(data).toBuffer());
  }

  public disconnect(): void {
    this.socket.destroy();
  }
}

export class WebSocketHathoraConnection extends HathoraConnection {
  constructor(public stateId: StateId, public state: UserState, private socket: WebSocket, onUpdate?: UpdateCallback, onError?: ErrorCallback) {
    super(stateId, state, onUpdate, onError);
    socket.onmessage = ({ data }) => {
      const reader = new Reader(new Uint8Array(data as ArrayBuffer));
      const type = reader.readUInt8();
      if (type === 0) {
        this.state = decodeStateSnapshot(reader);
        this.changedAt = 0;
        this.updateListeners.forEach((listener) =>
          listener({ stateId, state: JSON.parse(JSON.stringify(this.state)), updatedAt: 0, events: [] })
        );
      } else if (type === 1) {
        const { stateDiff, changedAtDiff, responses, events } = decodeStateUpdate(reader);
        if (stateDiff !== undefined) {
          this.state = computePatch(this.state!, stateDiff);
        }
        this.changedAt += changedAtDiff;
        this.updateListeners.forEach((listener) =>
          listener({
            stateId,
            state: JSON.parse(JSON.stringify(this.state)),
            updatedAt: this.changedAt,
            events: events.map((e) => e.event),
          })
        );
        responses.forEach(({ msgId, response }) => {
          if (msgId in this.callbacks) {
            this.callbacks[msgId](response);
            delete this.callbacks[msgId];
          }
        });
      } else if (type === 2) {
        this.disconnect(4004);
      } else {
        console.error("Unknown message type", type);
      }
    };
    socket.onclose = (e) => {
      console.error("Connection closed", e);
      this.errorListeners.forEach((listener) => listener(transformCoordinatorFailure(e)));
    };
  }

  public disconnect(code?: number): void {
    if (code === undefined) {
      this.socket.onclose = () => {};
    }
    this.socket.close(code);
  }

  protected callMethod(method: Method, request: Uint8Array): Promise<Response> {
    return new Promise((resolve, reject) => {
      if (this.socket.readyState !== this.socket.OPEN) {
        reject("Connection not open");
      } else {
        const msgId: Uint8Array = getRandomValues(new Uint8Array(4));
        this.socket.send(new Uint8Array([...new Uint8Array([method]), ...msgId, ...request]));
        this.callbacks[new DataView(msgId.buffer).getUint32(0)] = resolve;
      }
    });
  }
}
