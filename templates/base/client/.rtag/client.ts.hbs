import WebSocket from "isomorphic-ws";
// @ts-ignore
import getRandomValues from "get-random-values";
import axios from "axios";
import jwtDecode from "jwt-decode";
import { UserData, Response, Method } from "./base";
import {
  decodeState,
  {{userState}} as UserState,
  {{#each methods}}
  {{makeRequestName @key}},
  {{/each}}
} from "./types";

const COORDINATOR_HOST = "rtag.dev";

export type StateId = string;

export class RtagClient {
  public constructor(private appId: string) {}

  public static getUserFromToken(token: string): UserData {
    return jwtDecode(token);
  }

{{#each auth}}
{{#if (eq @key "anonymous")}}
  public async loginAnonymous(): Promise<string> {
    return (await axios.post(`https://${COORDINATOR_HOST}/${this.appId}/login/anonymous`)).data.token;
  }

{{else if (eq @key "google")}}
  public async loginGoogle(idToken: string): Promise<string> {
    return (await axios.post(`https://${COORDINATOR_HOST}/${this.appId}/login/google`, { idToken })).data.token;
  }

{{/if}}
{{/each}}
  public connectNew(
    token: string,
    request: {{makeRequestName initialize}},
    onStateChange: (state: UserState) => void,
    onEvent: (event: string) => void
  ): Promise<RtagConnection> {
    return new Promise((resolve, reject) => {
      const socket = this.initSocket(reject);
      socket.onopen = () => {
        socket.send(token);
        socket.send({{makeRequestName initialize}}.encode(request));
      };
      socket.onmessage = ({ data }) => {
        new RtagConnection(data as string, socket, resolve, onStateChange, onEvent);
      };
    });
  }

  public connectExisting(
    token: string,
    stateId: StateId,
    onStateChange: (state: UserState) => void,
    onEvent: (event: string) => void
  ): Promise<RtagConnection> {
    return new Promise((resolve, reject) => {
      const socket = this.initSocket(reject);
      new RtagConnection(stateId, socket, resolve, onStateChange, onEvent);
      socket.onopen = () => {
        socket.send(token);
        socket.send(stateId);
      };
    });
  }

  private initSocket(reject: (reason?: any) => void) {
    const socket = new WebSocket(`wss://${COORDINATOR_HOST}/${this.appId}`);
    socket.binaryType = "arraybuffer";
    socket.onerror = reject;
    socket.onclose = reject;
    return socket;
  }
}

export class RtagConnection {
  private callbacks: Record<string, (response: Response) => void> = {};

  public constructor(
    public stateId: StateId,
    private socket: WebSocket,
    resolve: (connection: RtagConnection) => void,
    onStateChange: (state: UserState) => void,
    onEvent: (event: string) => void
  ) {
    socket.onmessage = ({ data }) => {
      resolve(this);
      const { state, messages } = decodeState(new Uint8Array(data as ArrayBuffer));
      if (state !== undefined) {
        onStateChange(state);
      }
      messages.forEach((message) => {
        if (message.type === "response") {
          if (message.msgId in this.callbacks) {
            this.callbacks[message.msgId](message.response);
            delete this.callbacks[message.msgId];
          }
        } else {
          onEvent(message.event);
        }
      });
    };
  }

  {{#each methods}}
  {{#if (ne @key ../initialize)}}
  public {{@key}}(request: {{makeRequestName @key}}): Promise<Response> {
    return this.callMethod(Method.{{uppercase @key}}, {{makeRequestName @key}}.encode(request));
  }

  {{/if}}
  {{/each}}
  public disconnect(): void {
    this.socket.close();
  }

  private callMethod(method: Method, request: Uint8Array): Promise<Response> {
    return new Promise((resolve, reject) => {
      if (this.socket.readyState === this.socket.CLOSED) {
        reject("Connection is closed");
      } else {
        const msgId: Uint8Array = getRandomValues(new Uint8Array(4));
        this.socket.send(new Uint8Array([...new Uint8Array([method]), ...msgId, ...request]));
        this.callbacks[new DataView(msgId.buffer).getUint32(0, true)] = resolve;
      }
    });
  }
}
