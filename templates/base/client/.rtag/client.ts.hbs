import WebSocket from "isomorphic-ws";
import axios from "axios";
import jwtDecode from "jwt-decode";
import { decode, encode } from "@msgpack/msgpack";
import {
  UserData,
  {{userState}} as UserState,
  Method,
  {{#each methods}}
  {{makeRequestName @key}},
  {{/each}}
} from "./types";

const COORDINATOR_HOST = "rtag.dev";

export type StateId = string;

export class RtagClient {
  private socket: WebSocket | undefined;
  private callbacks: Record<string, (response: {{error.typeString}} | undefined) => void> = {};

  public constructor(private appId: string) {}

  public static getUserFromToken(token: string): UserData {
    return jwtDecode(token);
  }

{{#each auth}}
{{#if (eq @key "anonymous")}}
  public async loginAnonymous(): Promise<string> {
    return (await axios.post(`https://${COORDINATOR_HOST}/${this.appId}/login/anonymous`)).data.token;
  }

{{else if (eq @key "google")}}
  public async loginGoogle(idToken: string): Promise<string> {
    return (await axios.post(`https://${COORDINATOR_HOST}/${this.appId}/login/google`, { idToken })).data.token;
  }

{{/if}}
{{/each}}
  public connectNew(
    token: string,
    request: {{makeRequestName initialize}},
    onStateChange: (state: UserState) => void
  ): Promise<{ stateId: string }> {
    return new Promise((resolve, reject) => {
      this.socket = this.initClient(reject);
      this.socket.onopen = () => {
        this.socket.send(token);
        this.socket.send(encode(request, { ignoreUndefined: true }));
      };
      let first = true;
      this.socket.onmessage = ({ data }) => {
        if (first) {
          resolve({ stateId: data as string });
          first = false;
          return;
        }
        this.handleStateChange(data as ArrayBuffer, onStateChange);
      };
    });
  }

  public connectExisting(token: string, stateId: StateId, onStateChange: (state: UserState) => void): Promise<void> {
    return new Promise((resolve, reject) => {
      this.socket = this.initClient(reject);
      this.socket.onopen = () => {
        this.socket.send(token);
        this.socket.send(stateId);
      };
      let first = true;
      this.socket.onmessage = ({ data }) => {
        if (first) {
          resolve();
          first = false;
        }
        this.handleStateChange(data as ArrayBuffer, onStateChange);
      };
    });
  }

  {{#each methods}}
  {{#if (ne @key ../initialize)}}
  public {{@key}}(request: {{makeRequestName @key}}): Promise<{{../error.typeString}} | undefined> {
    return this.callMethod(Method.{{uppercase @key}}, request);
  }

  {{/if}}
  {{/each}}
  public disconnect(): void {
    this.socket?.close();
  }

  private initClient(reject: (reason?: any) => void) {
    const socket = new WebSocket(`wss://${COORDINATOR_HOST}/${this.appId}`);
    socket.binaryType = "arraybuffer";
    socket.onerror = reject;
    socket.onclose = reject;
    return socket;
  }

  private handleStateChange(data: ArrayBuffer, onStateChange: (state: UserState) => void) {
    const { state, responses } = decode(data) as { state: UserState; responses: Record<string, string | null> };
    onStateChange(state);
    Object.entries(responses).forEach(([msgId, response]) => {
      if (msgId in this.callbacks) {
        this.callbacks[msgId](response ?? undefined);
        delete this.callbacks[msgId];
      }
    });
  }

  private callMethod(method: Method, request: unknown): Promise<string | undefined> {
    return new Promise((resolve, reject) => {
      if (this.socket === undefined) {
        reject("Connection not established");
      } else if (this.socket.readyState === this.socket.CLOSED) {
        reject("Connection is closed");
      } else {
        const msgId = crypto.getRandomValues(new Uint32Array(1));
        const args = encode(request, { ignoreUndefined: true });
        this.socket.send(new Uint8Array([...new Uint8Array([method]), ...new Uint8Array(msgId.buffer), ...args]));
        this.callbacks[msgId[0]] = resolve;
      }
    });
  }
}
