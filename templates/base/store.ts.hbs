import { watch } from "fs";
import module from "module";
import onChange from "on-change";
import { UserId, PlayerState } from "./types";

const require = module.createRequire(import.meta.url);
let impl = new (await import("../impl")).Impl();
watch(require.resolve("../impl"), async () => {
  impl = new (await import(`../impl.ts#${Math.random()}`)).Impl();
});

type StateId = string;
type State = ReturnType<typeof impl.{{initialize}}>;
const states: Map<StateId, State> = new Map();
const changedStates: Set<StateId> = new Set();
const subscriptions: Map<StateId, Set<UserId>> = new Map();

export default class Store {
  constructor(onNewUserState: (stateId: StateId, userId: UserId, userState: PlayerState) => void) {
    setInterval(() => {
      {{#if tick}}
      states.forEach(impl.onTick);
      {{/if}}
      changedStates.forEach((stateId) => {
        subscriptions
          .get(stateId)!
          .forEach((userId) => onNewUserState(stateId, userId, impl.getUserState(states.get(stateId)!, userId)));
      });
      changedStates.clear();
    }, 50);
  }
  newState(stateId: StateId, userId: UserId, req: any) {
    const state = impl.{{initialize}}(userId, req);
    states.set(
      stateId,
      onChange(state, () => {
        changedStates.add(stateId);
      })
    );
  }
  handleUpdate(stateId: StateId, userId: UserId, method: string, args: any) {
    const state = states.get(stateId)!;
    switch (method) {
      {{#each methods}}
      {{#if (ne @key ../initialize)}}
      case "{{@key}}":
        return impl.{{@key}}(state, userId, args);
      {{/if}}
      {{/each}}
    }
    return "Invalid method";
  }
  hasState(stateId: StateId) {
    return states.has(stateId);
  }
  getUserState(stateId: StateId, userId: UserId) {
    const state = states.get(stateId);
    return state !== undefined ? impl.getUserState(state, userId) : undefined;
  }
  subscribeUser(stateId: StateId, userId: UserId) {
    if (!subscriptions.has(stateId)) {
      subscriptions.set(stateId, new Set([userId]));
    } else {
      subscriptions.get(stateId)!.add(userId);
    }
  }
  unsubscribeUser(stateId: StateId, userId: UserId) {
    const users = subscriptions.get(stateId)!;
    if (users.size > 1) {
      users.delete(userId);
    } else {
      subscriptions.delete(stateId);
    }
  }
}
