import { SmartBuffer } from "smart-buffer";
import varint from "varint";
import { Response } from "./base";

{{#each types}}
{{#if (eq type "enum")}}
export enum {{@key}} {
  {{#each options}}
  {{label}},
  {{/each}}
}
{{else if (eq type "union")}}
export type {{@key}} = {{#each options}}{{#unless @first}} | {{/unless}}{ type: "{{> renderTypeArg}}"; val: {{> renderTypeArg}} }{{/each}};
{{else if (eq type "object")}}
export type {{@key}} = {
  {{#each properties}}
  {{@key}}{{#if (eq type "optional")}}?{{/if}}: {{> renderTypeArg}};
  {{/each}}
};
{{else}}
export type {{@key}} = {{> renderTypeArg}};
{{/if}}
{{/each}}
{{#each methods}}
export type {{makeRequestName @key}} = {
  {{#each properties}}
  {{@key}}{{#if (eq type "optional")}}?{{/if}}: {{> renderTypeArg}};
  {{/each}}
};
{{/each}}

{{#each types}}
{{#if (eq type "object")}}
export const {{@key}} = {
  default(): {{@key}} {
    return {
      {{#each properties}}
      {{@key}}: {{> renderDefault}},
      {{/each}}
    };
  },
  encode(obj: {{@key}}, buf?: SmartBuffer) {
    buf ??= new SmartBuffer();
    {{#each properties}}
    {{> renderEncodeArg arg=@key}};
    {{/each}}
    return buf.toBuffer();
  },
  decode(buf: Buffer | SmartBuffer): {{@key}} {
    const sb = buf instanceof Buffer ? SmartBuffer.fromBuffer(buf) : buf;
    return {
      {{#each properties}}
      {{@key}}: {{> renderDecodeArg}},
      {{/each}}
    };
  },
}
{{else if (eq type "union")}}
export const {{@key}} = {
  values() {
    return [{{#each options}}"{{@key}}"{{#unless @last}}, {{/unless}}{{/each}}];
  },
  encode(obj: Uni, buf?: SmartBuffer) {
    buf ??= new SmartBuffer();
    writeUInt(buf, this.values().indexOf(obj.type));
    {{#each options}}
    {{#unless @first}}else {{/unless}}if (obj.type === "{{@key}}") {
      const x = obj.val;
      {{> renderEncodeArg}};
    }
    {{/each}}
    return buf.toBuffer();
  },
  decode(buf: Buffer | SmartBuffer): Uni {
    const sb = buf instanceof Buffer ? SmartBuffer.fromBuffer(buf) : buf;
    const type = parseUInt(sb);
    {{#each options}}
    {{#unless @first}}else {{/unless}}if (type === {{@index}}) {
      return { type: "{{@key}}", val: {{> renderDecodeArg}} };
    }
    {{/each}}
    throw new Error("Invalid union");
  },
}
{{/if}}
{{/each}}
{{#each methods}}
export const {{makeRequestName @key}} = {
  default(): {{makeRequestName @key}} {
    return {
      {{#each properties}}
      {{@key}}: {{> renderDefault}},
      {{/each}}
    };
  },
  encode(obj: {{makeRequestName @key}}, buf?: SmartBuffer) {
    buf ??= new SmartBuffer();
    {{#each properties}}
    {{> renderEncodeArg arg=@key}};
    {{/each}}
    return buf.toBuffer();
  },
  decode(buf: Buffer | SmartBuffer): {{makeRequestName @key}} {
    const sb = buf instanceof Buffer ? SmartBuffer.fromBuffer(buf) : buf;
    return {
      {{#each properties}}
      {{@key}}: {{> renderDecodeArg}},
      {{/each}}
    };
  }
}
{{/each}}
{{#*inline "renderTypeArg"}}
{{#if alias}}
{{typeString}}
{{~else if (eq type "optional")}}
{{> renderTypeArg item}}
{{~else if (eq type "array")}}
{{> renderTypeArg items}}[]
{{~else if (eq type "number")}}
number
{{~else if (eq type "string")}}
string
{{~else if (eq type "boolean")}}
boolean
{{~else if (eq type "plugin")}}
{{> renderTypeArg item}}
{{~/if}}
{{~/inline}}
{{#*inline "renderDefault"}}
{{#if (eq type "array")}}
[]
{{~else if (eq type "number")}}
0
{{~else if (eq type "string")}}
""
{{~else if (eq type "enum")}}
0
{{~else if (eq type "boolean")}}
false
{{~else if (eq type "optional")}}
undefined
{{~else if (eq type "object")}}
{{typeString}}.default()
{{~else if (eq type "union")}}
{{#each options}}
{{#if @first}}
{ type: "{{@key}}", val: {{@key}}.default() }
{{~/if}}
{{/each}}
{{/if}}
{{/inline}}
{{#*inline "renderEncodeArg"}}
{{#if (eq type "optional")}}
writeOptional(buf, obj.{{arg}}, (buf, x) => {{> renderEncodeArg item}})
{{~else if (eq type "array")}}
writeArray(buf, {{#if arg}}obj.{{arg}}{{else}}x{{/if}}, (buf, x) => {{> renderEncodeArg items}})
{{~else if (eq type "enum")}}
writeUInt(buf, {{#if arg}}obj.{{arg}}{{else}}x{{/if}})
{{~else if (eq type "number")}}
writeNumber(buf, {{#if arg}}obj.{{arg}}{{else}}x{{/if}})
{{~else if (eq type "string")}}
writeString(buf, {{#if arg}}obj.{{arg}}{{else}}x{{/if}})
{{~else if (eq type "boolean")}}
writeBoolean(buf, {{#if arg}}obj.{{arg}}{{else}}x{{/if}})
{{~else if (eq type "plugin")}}
{{> renderEncodeArg item arg=arg}}
{{~else}}
{{typeString}}.encode({{#if arg}}obj.{{arg}}{{else}}x{{/if}}, buf)
{{~/if}}
{{/inline}}
{{#*inline "renderDecodeArg"}}
{{#if (eq type "optional")}}
parseOptional(sb, () => {{> renderDecodeArg item}})
{{~else if (eq type "array")}}
parseArray(sb, () => {{> renderDecodeArg items}})
{{~else if (eq type "enum")}}
parseUInt(sb)
{{~else if (eq type "number")}}
parseNumber(sb)
{{~else if (eq type "string")}}
parseString(sb)
{{~else if (eq type "boolean")}}
parseBoolean(sb)
{{~else if (eq type "plugin")}}
{{> renderDecodeArg item}}
{{~else}}
{{typeString}}.decode(sb)
{{~/if}}
{{/inline}}

export function encodeState(state: {{userState}} | undefined, responses: Record<number, Response>) {
  const buf = new SmartBuffer();
  writeOptional(buf, state, (buf, x) => {{userState}}.encode(x, buf));
  Object.entries(responses).forEach(([msgId, response]) => {
    buf.writeUInt32LE(Number(msgId));
    const maybeError = response.type === "error" ? response.error : undefined;
    writeOptional(buf, maybeError, writeString);
  });
  return buf.toBuffer();
}
export function decodeState(buf: Buffer | SmartBuffer): { state?: {{userState}}; responses: Record<number, Response> } {
  const sb = buf instanceof Buffer ? SmartBuffer.fromBuffer(buf) : buf;
  const state = parseOptional(sb, () => {{userState}}.decode(sb));
  const responses: Record<number, Response> = {};
  while (sb.remaining() > 0) {
    const msgId = sb.readUInt32LE();
    const maybeError = parseOptional(sb, () => parseString(sb));
    responses[msgId] = maybeError === undefined ? Response.ok() : Response.error(maybeError);
  }
  return { state, responses };
}

function writeUInt(buf: SmartBuffer, x: number) {
  buf.writeUInt8(x);
}
function writeBoolean(buf: SmartBuffer, x: boolean) {
  buf.writeUInt8(x ? 1 : 0);
}
function writeNumber(buf: SmartBuffer, x: number) {
  buf.writeDoubleLE(x);
}
function writeString(buf: SmartBuffer, x: string) {
  buf.writeBuffer(Buffer.from(varint.encode(x.length)));
  buf.writeString(x);
}
function writeOptional<T>(buf: SmartBuffer, x: T | undefined, innerWrite: (buf: SmartBuffer, x: T) => void) {
  writeBoolean(buf, x !== undefined);
  if (x !== undefined) {
    innerWrite(buf, x);
  }
}
function writeArray<T>(buf: SmartBuffer, x: T[], innerWrite: (buf: SmartBuffer, x: T) => void) {
  buf.writeBuffer(Buffer.from(varint.encode(x.length)));
  for (let i = 0; i < x.length; i++) {
    innerWrite(buf, x[i]);
  }
}

function parseUInt(buf: SmartBuffer): number {
  return buf.readUInt8();
}
function parseBoolean(buf: SmartBuffer): boolean {
  return buf.readUInt8() > 0;
}
function parseNumber(buf: SmartBuffer): number {
  return buf.readDoubleLE();
}
function parseString(buf: SmartBuffer): string {
  const len = varint.decode(buf.internalBuffer, buf.readOffset);
  buf.readOffset += varint.decode.bytes;
  return buf.readString(len);
}
function parseOptional<T>(buf: SmartBuffer, innerParse: (buf: SmartBuffer) => T): T | undefined {
  return parseBoolean(buf) ? innerParse(buf) : undefined;
}
function parseArray<T>(buf: SmartBuffer, innerParse: (buf: SmartBuffer) => T): T[] {
  const len = varint.decode(buf.internalBuffer, buf.readOffset);
  buf.readOffset += varint.decode.bytes;
  const arr = [];
  for (let i = 0; i < len; i++) {
    arr.push(innerParse(buf));
  }
  return arr;
}
