import net from "net";
import retry from "retry";
import { SmartBuffer } from "smart-buffer";

const NEW_STATE = 0;
const SUBSCRIBE_USER = 1;
const UNSUBSCRIBE_USER = 2;
const HANDLE_UPDATE = 3;

export function getStore(
  onNewUserState: (stateId: bigint, userId: string, data: Buffer) => void
): Promise<StoreClient> {
  return new Promise((resolve) => {
    const server = net.createServer((socket) => {
      socket.on("data", (data) => {
        const reader = SmartBuffer.fromBuffer(data);
        while (reader.remaining() > 0) {
          onNewUserState(reader.readBigUInt64LE(), reader.readStringNT(), reader.readBuffer(reader.readUInt32LE()));
        }
      });
      resolve(new StoreClient(socket));
    });
    server.listen(3001, "127.0.0.1");
  });
}

export function register(store: Store): Promise<ProxyClient> {
  return new Promise((resolve, reject) => {
    const socket = new net.Socket();
    const operation = retry.operation();
    operation.attempt(() => {
      socket.connect(3001, "127.0.0.1", () => {
        resolve(new ProxyClient(socket));
      });
    });
    socket.on("error", (err) => {
      if (!operation.retry(err)) {
        reject(operation.mainError);
      }
    });
    socket.on("data", (data) => {
      const reader = SmartBuffer.fromBuffer(data);
      const type = reader.readInt8();
      if (type === NEW_STATE) {
        store.newState(
          reader.readBigUInt64LE(),
          reader.readBuffer(reader.readUInt32LE()),
          reader.readBuffer(reader.readUInt32LE())
        );
      } else if (type === SUBSCRIBE_USER) {
        store.subscribeUser(reader.readBigUInt64LE(), reader.readBuffer(reader.readUInt32LE()));
      } else if (type === UNSUBSCRIBE_USER) {
        store.unsubscribeUser(reader.readBigUInt64LE(), reader.readStringNT());
      } else if (type === HANDLE_UPDATE) {
        store.handleUpdate(reader.readBigUInt64LE(), reader.readStringNT(), reader.readBuffer(reader.readUInt32LE()));
      }
    });
  });
}

interface Store {
  newState(stateId: bigint, userBuffer: Buffer, args: Buffer): void;
  subscribeUser(stateId: bigint, userBuffer: Buffer): void;
  unsubscribeUser(stateId: bigint, userId: string): void;
  handleUpdate(stateId: bigint, userId: string, data: Buffer): void;
}

class StoreClient implements Store {
  constructor(private socket: net.Socket) {}

  public newState(stateId: bigint, user: Buffer, args: Buffer) {
    const buf = new SmartBuffer()
      .writeInt8(NEW_STATE)
      .writeBigUInt64LE(stateId)
      .writeUInt32LE(user.byteLength)
      .writeBuffer(user)
      .writeUInt32LE(args.length)
      .writeBuffer(args);
    this.socket.write(buf.toBuffer());
  }

  public subscribeUser(stateId: bigint, user: Buffer) {
    const buf = new SmartBuffer()
      .writeInt8(SUBSCRIBE_USER)
      .writeBigUInt64LE(stateId)
      .writeUInt32LE(user.byteLength)
      .writeBuffer(user);
    this.socket.write(buf.toBuffer());
  }

  public unsubscribeUser(stateId: bigint, userId: string) {
    const buf = new SmartBuffer().writeInt8(UNSUBSCRIBE_USER).writeBigUInt64LE(stateId).writeStringNT(userId);
    this.socket.write(buf.toBuffer());
  }

  public handleUpdate(stateId: bigint, userId: string, data: Buffer) {
    const buf = new SmartBuffer()
      .writeInt8(HANDLE_UPDATE)
      .writeBigUInt64LE(stateId)
      .writeStringNT(userId)
      .writeUInt32LE(data.length)
      .writeBuffer(data);
    this.socket.write(buf.toBuffer());
  }
}

class ProxyClient {
  constructor(private socket: net.Socket) {}

  public onNewUserState(stateId: bigint, userId: string, data: Buffer) {
    const buf = new SmartBuffer()
      .writeBigUInt64LE(stateId)
      .writeStringNT(userId)
      .writeUInt32LE(data.length)
      .writeBuffer(data);
    this.socket.write(buf.toBuffer());
  }
}
