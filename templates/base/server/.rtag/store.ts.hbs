import module from "module";
import onChange from "on-change";
import dependencyTree from "dependency-tree";
import chokidar from "chokidar";
import seedrandom from "seedrandom";
import { UserData, {{userState}} as UserState, Result, {{makeRequestName initialize}} } from "./types";

const deps = dependencyTree.toList({
  directory: ".",
  filename: module.createRequire(import.meta.url).resolve("../impl"),
  filter: (path) => !path.includes(".rtag") && !path.includes("node_modules"),
});
let impl = new (await import("../impl")).Impl();
chokidar.watch(deps).on("change", async () => {
  impl = new (await import(`../impl.ts#${Math.random()}`)).Impl();
});

type StateId = string;
type State = ReturnType<typeof impl.{{initialize}}>;
const states: Map<StateId, State> = new Map();
const changedStates: Set<StateId> = new Set();
const userResults: Map<string, Record<string, Result>> = new Map();
const subscriptions: Map<StateId, Set<UserData>> = new Map();
const rng = seedrandom(Math.random().toString());

export default class Store {
  constructor(
    onNewUserState: (stateId: StateId, user: UserData, userState: UserState, results: Record<string, Result>) => void
  ) {
    setInterval(() => {
      {{#if tick}}
      states.forEach((state) => impl.onTick(state, ctx()));
      {{/if}}
      changedStates.forEach((stateId) => {
        subscriptions
          .get(stateId)!
          .forEach((user) =>
            onNewUserState(stateId, user, impl.getUserState(states.get(stateId)!, user), userResults.get(user.id) ?? {})
          );
      });
      changedStates.clear();
      userResults.clear();
    }, 50);
  }
  newState(stateId: StateId, user: UserData, req: {{makeRequestName initialize}}) {
    const state = impl.{{initialize}}(user, ctx(), req);
    states.set(
      stateId,
      onChange(state, () => {
        changedStates.add(stateId);
      })
    );
  }
  handleUpdate(stateId: StateId, user: UserData, msgId: string, method: string, args: any) {
    const result = getResult(states.get(stateId)!, user, method, args);
    if (result !== undefined) {
      if (!userResults.has(user.id)) {
        userResults.set(user.id, { [msgId]: result });
      } else {
        userResults.get(user.id)![msgId] = result;
      }
    }
  }
  hasState(stateId: StateId) {
    return states.has(stateId);
  }
  getUserState(stateId: StateId, user: UserData) {
    const state = states.get(stateId);
    return state !== undefined ? impl.getUserState(state, user) : undefined;
  }
  subscribeUser(stateId: StateId, user: UserData) {
    if (!subscriptions.has(stateId)) {
      subscriptions.set(stateId, new Set([user]));
    } else {
      subscriptions.get(stateId)!.add(user);
    }
  }
  unsubscribeUser(stateId: StateId, user: UserData) {
    const users = subscriptions.get(stateId)!;
    if (users.size > 1) {
      users.delete(user);
    } else {
      subscriptions.delete(stateId);
    }
  }
}

function getResult(state: State, user: UserData, method: string, args: any) {
  switch (method) {
    {{#each methods}}
    {{#if (ne @key ../initialize)}}
    case "{{@key}}":
      return impl.{{@key}}(state, user, ctx(), args);
    {{/if}}
    {{/each}}
    default:
      return undefined;
  }
}

function ctx() {
  return {
    rand: () => rng(),
    randInt: (limit?: number) => (limit === undefined ? rng.int32() : Math.floor(rng() * limit)),
    time: () => Date.now(),
  };
}
