import { randomBytes } from "crypto";
import { existsSync, mkdirSync } from "fs";
import seedrandom from "seedrandom";
import { decode } from "@msgpack/msgpack";
import { SmartBuffer } from "smart-buffer";
import "dotenv/config";
import { register } from "./protocol";
import LogStore from "./logstore";
import { ImplWrapper as impl } from "./wrapper";
import { UserData, Message } from "./base";
import { encodeState } from "./types";

type StateId = bigint;
type UserId = string;
type State = ReturnType<typeof impl.initialize>;
type StateInfo = { state: State; rng: ReturnType<seedrandom>; subscriptions: Map<UserId, UserData> };

const dataDir = process.env.DATA_DIR!;
if (!existsSync(dataDir)) {
  mkdirSync(dataDir);
}
const log = new LogStore(dataDir);
const stateInfo: Map<StateId, StateInfo> = new Map();
const changedStates: Set<StateId> = new Set();
const userMessages: Map<StateId, Map<UserId, Message[]>> = new Map();

class Store {
  constructor() {
    setInterval(() => {
      changedStates.forEach((stateId) => {
        const messages = userMessages.get(stateId);
        stateInfo.get(stateId)?.subscriptions.forEach((user, userId) => {
          sendUpdate(stateId, stateInfo.get(stateId)!.state, user, messages?.get(userId) ?? []);
        });
        userMessages.delete(stateId);
      });
      userMessages.forEach((messages, stateId) => {
        messages.forEach((message, userId) => {
          const user = stateInfo.get(stateId)?.subscriptions?.get(userId);
          if (user !== undefined) {
            sendUpdate(stateId, undefined, user, message);
          }
        });
      });
      changedStates.clear();
      userMessages.clear();
    }, {{tick}});
    {{#if tick}}

    let prevUpdateTime = Date.now();
    setInterval(() => {
      const currTime = Date.now();
      stateInfo.forEach(({ state, rng }, stateId) => {
        const timeDelta = currTime - prevUpdateTime;
        impl.onTick(state, ctx(rng, currTime, handleEvent(stateId)), timeDelta / 1000);
        if (impl.changed()) {
          changedStates.add(stateId);
          log.append(stateId, currTime, new SmartBuffer().writeUInt8(0xfe).writeUInt32LE(timeDelta).toBuffer());
        }
      });
      prevUpdateTime = currTime;
    }, 50);
    {{/if}}
  }
  async newState(stateId: StateId, userId: UserId, argsBuffer: Buffer) {
    const userBuffer = await coordinator.lookupUser(userId);
    const user = decode(userBuffer) as UserData;
    const seed = randomBytes(8).readBigUInt64LE();
    const rng = seedrandom(seed.toString(36));
    const time = Date.now();
    const state = impl.initialize(user, ctx(rng, time, handleEvent(stateId)), argsBuffer);
    stateInfo.set(stateId, { state, rng, subscriptions: new Map([[userId, user]]) });
    sendUpdate(stateId, state, user, []);
    log.append(
      stateId,
      time,
      new SmartBuffer()
        .writeBigUInt64LE(seed)
        .writeUInt32LE(userBuffer.length)
        .writeBuffer(userBuffer)
        .writeUInt32LE(argsBuffer.length)
        .writeBuffer(argsBuffer)
        .toBuffer()
    );
  }
  async subscribeUser(stateId: StateId, userId: UserId) {
    const userBuffer = await coordinator.lookupUser(userId);
    const user = decode(userBuffer) as UserData;
    if (!stateInfo.has(stateId)) {
      const loaded = loadState(stateId);
      if (loaded === undefined) {
        coordinator.onStateUpdate(stateId, userId, Buffer.alloc(0));
        return;
      }
      stateInfo.set(stateId, { state: loaded.state, rng: loaded.rng, subscriptions: new Map() });
    }
    stateInfo.get(stateId)!.subscriptions.set(userId, user);
    sendUpdate(stateId, stateInfo.get(stateId)!.state, user, []);
    log.append(
      stateId,
      Date.now(),
      new SmartBuffer().writeUInt8(0xff).writeUInt32LE(userBuffer.length).writeBuffer(userBuffer).toBuffer()
    );
  }
  unsubscribeUser(stateId: StateId, userId: UserId) {
    if (!stateInfo.has(stateId)) {
      return;
    }
    const subscribers = stateInfo.get(stateId)!.subscriptions;
    if (subscribers.size > 1) {
      subscribers.delete(userId);
    } else {
      stateInfo.delete(stateId);
      changedStates.delete(stateId);
      userMessages.delete(stateId);
      log.unload(stateId);
    }
  }
  handleUpdate(stateId: StateId, userId: UserId, data: Buffer) {
    if (!stateInfo.has(stateId)) {
      return;
    }
    const { state, rng, subscriptions } = stateInfo.get(stateId)!;
    const reader = SmartBuffer.fromBuffer(data);
    const [method, msgId, argsBuffer] = [reader.readUInt8(), reader.readUInt32LE(), reader.readBuffer()];
    const user = subscriptions.get(userId)!;
    const time = Date.now();
    const response = impl.getResult(state, user, method, ctx(rng, time, handleEvent(stateId)), argsBuffer);
    if (response !== undefined) {
      if (impl.changed()) {
        changedStates.add(stateId);
        log.append(
          stateId,
          time,
          new SmartBuffer()
            .writeUInt8(method)
            .writeUInt32LE(userId.length)
            .writeString(userId)
            .writeUInt32LE(argsBuffer.length)
            .writeBuffer(argsBuffer)
            .toBuffer()
        );
      }
      if (!userMessages.has(stateId)) {
        userMessages.set(stateId, new Map([[userId, [{ type: "response", msgId, response }]]]));
      } else {
        if (!userMessages.get(stateId)!.has(userId)) {
          userMessages.get(stateId)!.set(userId, [{ type: "response", msgId, response }]);
        } else {
          userMessages.get(stateId)!.get(userId)!.push({ type: "response", msgId, response });
        }
      }
    }
  }
}

const coordinator = await register(new Store());

function loadState(stateId: StateId) {
  try {
    const rows = log.load(stateId);
    const users: Map<UserId, UserData> = new Map();

    const { time, record } = rows[0];
    const reader = SmartBuffer.fromBuffer(record);
    const seed = reader.readBigUInt64LE();
    const userBuffer = reader.readBuffer(reader.readUInt32LE());
    const argsBuffer = reader.readBuffer(reader.readUInt32LE());
    const user = decode(userBuffer) as UserData;
    users.set(user.id, user);
    const rng = seedrandom(seed.toString(36));
    const state = impl.initialize(user, ctx(rng, time, handleEvent(stateId)), argsBuffer);

    for (let i = 1; i < rows.length; i++) {
      const { time, record } = rows[i];
      const reader = SmartBuffer.fromBuffer(record);
      const method = reader.readUInt8();
      if (method === 0xff) {
        const userBuffer = reader.readBuffer(reader.readUInt32LE());
        const user = decode(userBuffer) as UserData;
        users.set(user.id, user);
        continue;
      }
      {{#if tick}}
      if (method === 0xfe) {
        const timeDelta = reader.readUInt32LE();
        impl.onTick(state, ctx(rng, time, handleEvent(stateId)), timeDelta / 1000);
        continue;
      }
      {{/if}}
      const userId = reader.readString(reader.readUInt32LE());
      const argsBuffer = reader.readBuffer(reader.readUInt32LE());
      impl.getResult(state, users.get(userId)!, method, ctx(rng, time, noop), argsBuffer);
    }

    return { state, rng };
  } catch (e) {
    console.error("Unable to load state", stateId.toString(36), e);
  }
}

function sendUpdate(stateId: StateId, state: State | undefined, user: UserData, messages: Message[]) {
  const userState = state === undefined ? undefined : impl.getUserState(state, user);
  return coordinator.onStateUpdate(stateId, user.id, Buffer.from(encodeState(userState, messages)));
}

function ctx(rng: ReturnType<seedrandom>, time: number, handleEvent: (event: string, userId: UserId) => void) {
  return {
    rand: () => rng(),
    randInt: (limit?: number) => (limit === undefined ? rng.int32() : Math.floor(rng() * limit)),
    time: () => time,
    event: handleEvent,
  };
}

function handleEvent(stateId: StateId) {
  return (event: string, userId: UserId) => {
    const messages = userMessages.get(stateId);
    if (messages === undefined) {
      userMessages.set(stateId, new Map([[userId, [{ type: "event", event }]]]));
    } else {
      if (!messages.has(userId)) {
        messages.set(userId, [{ type: "event", event }]);
      } else {
        messages.get(userId)!.push({ type: "event", event });
      }
    }
  };
}

function noop() {}
