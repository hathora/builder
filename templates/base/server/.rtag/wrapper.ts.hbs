import { Context } from "./methods";
import { Response, Method } from "./base";
import {
  UserId,
  {{#each methods}}
  {{makeRequestName @key}},
  {{/each}}
} from "./types";

let impl = new (await import("../impl")).Impl();
setInterval(async () => {
  impl = new (await import("../impl")).Impl();
}, 100);

type State = ReturnType<typeof impl.{{initialize}}>;

let changed = false;
const PROXY_TARGET = Symbol("proxy-target");
const handler: ProxyHandler<any> = {
  get(target: any, property: string | symbol) {
    if (property === PROXY_TARGET) {
      return target;
    }
    const res = Reflect.get(target, property);
    if (res === undefined || res === null) {
      return res;
    } else if (res.hasOwnProperty("_modCnt")) {
      return new Proxy(res, {
        set(target: any, property: string | symbol, value: any): boolean {
          if (property === "_modCnt") {
            changed = true;
          }
          return Reflect.set(target, property, value);
        },
      });
    } else if ((typeof res === "object" || typeof res === "function") && property !== "constructor") {
      return new Proxy(res, handler);
    } else {
      return res;
    }
  },
  set(target: any, property: string | symbol, value: any): boolean {
    const prevValue = (target[PROXY_TARGET] ?? target)[property];
    if (!Object.is(prevValue, value)) {
      changed = true;
    }
    return Reflect.set(target, property, value);
  },
  apply(target: Function, thisArg: any, args: any) {
    if (
      Array.isArray(thisArg) &&
      ["push", "pop", "shift", "unshift", "copyWithin", "reverse", "sort", "splice", "flat", "fill"].includes(
        target.name
      )
    ) {
      changed = true;
    } else if (thisArg instanceof Set && ["add", "delete", "clear"].includes(target.name)) {
      changed = true;
    } else if (thisArg instanceof Map && ["set", "delete", "clear"].includes(target.name)) {
      changed = true;
    }
    const origThis = thisArg[PROXY_TARGET];
    const res = Reflect.apply(target, thisArg instanceof Set || thisArg instanceof Map ? origThis : thisArg, args);
    if (
      res !== undefined &&
      res !== null &&
      (Object.getPrototypeOf(res) === Object.prototype ||
        Array.isArray(res) ||
        res instanceof Set ||
        res instanceof Map)
    ) {
      return new Proxy(res, handler);
    }
    return res;
  },
};

export const ImplWrapper = {
  initialize(userId: UserId, ctx: Context, argsBuffer: Buffer): State {
    const state = impl.{{initialize}}(userId, ctx, {{makeRequestName initialize}}.decode(argsBuffer));
    return new Proxy(state, handler);
  },
  getResult(state: State, userId: UserId, method: Method, ctx: Context, argsBuffer: Buffer): Response | undefined {
    switch (method) {
      {{#each methods}}
      {{#if (ne @key ../initialize)}}
      case Method.{{uppercase @key}}:
        return impl.{{@key}}(state, userId, ctx, {{makeRequestName @key}}.decode(argsBuffer));
      {{/if}}
      {{/each}}
      default:
        return undefined;
    }
  },
  {{#if tick}}
  onTick(state: State, ctx: Context, timeDelta: number): void {
    impl.onTick(state, ctx, timeDelta);
  },
  {{/if}}
  getUserState(state: State, userId: UserId) {
    return impl.getUserState((state as any)[PROXY_TARGET], userId);
  },
  changed(): boolean {
    const res = changed;
    changed = false;
    return res;
  },
};
