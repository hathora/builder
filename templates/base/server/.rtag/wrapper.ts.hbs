import { Context } from "./methods";
import { UserData, Response, Method } from "./base";
import {
  {{#each methods}}
  {{makeRequestName @key}},
  {{/each}}
} from "./types";

let impl = new (await import("../impl")).Impl();
setInterval(async () => {
  impl = new (await import("../impl")).Impl();
}, 100);

type State = ReturnType<typeof impl.{{initialize}}>;

let changed = false;
const PROXY_TARGET = Symbol("proxy-target");
const handler: ProxyHandler<any> = {
  get(target: any, property: string | symbol) {
    if (property === PROXY_TARGET) {
      return target;
    }
    const res = Reflect.get(target, property);
    if (res === undefined || res === null) {
      return res;
    } else if (res.hasOwnProperty("_modCnt")) {
      return new Proxy(res, {
        set(target: any, property: string | symbol, value: any): boolean {
          if (property === "_modCnt") {
            changed = true;
          }
          return Reflect.set(target, property, value);
        },
      });
    } else if ((typeof res === "object" || typeof res === "function") && property !== "constructor") {
      return new Proxy(res, handler);
    } else {
      return res;
    }
  },
  set(target: any, property: string | symbol, value: any): boolean {
    const prevValue = (target[PROXY_TARGET] ?? target)[property];
    if (!Object.is(prevValue, value)) {
      changed = true;
    }
    return Reflect.set(target, property, value);
  },
  apply(target: Function, thisArg: any, args: any) {
    if (
      Array.isArray(thisArg) &&
      ["push", "pop", "shift", "unshift", "copyWithin", "reverse", "sort", "splice", "flat", "fill"].includes(
        target.name
      )
    ) {
      changed = true;
    } else if (thisArg instanceof Set && ["add", "delete", "clear"].includes(target.name)) {
      changed = true;
    } else if (thisArg instanceof Map && ["set", "delete", "clear"].includes(target.name)) {
      changed = true;
    }
    const origThis = thisArg[PROXY_TARGET];
    const res = Reflect.apply(
      target,
      (Array.isArray(thisArg) &&
        ![
          "entries",
          "every",
          "filter",
          "find",
          "flatMap",
          "forEach",
          "map",
          "reduce",
          "reduceRight",
          "some",
          "values",
        ].includes(target.name)) ||
        thisArg instanceof Set ||
        thisArg instanceof Map
        ? origThis
        : thisArg,
      args
    );
    if (
      res !== undefined &&
      res !== null &&
      (Object.getPrototypeOf(res) === Object.prototype ||
        Array.isArray(res) ||
        res instanceof Set ||
        res instanceof Map)
    ) {
      return new Proxy(res, handler);
    }
    return res;
  },
};

export const ImplWrapper = {
  initialize(user: UserData, ctx: Context, argsBuffer: Buffer): State {
    const state = impl.{{initialize}}(user, ctx, {{makeRequestName initialize}}.decode(argsBuffer));
    return new Proxy(state, handler);
  },
  getResult(state: State, user: UserData, method: Method, ctx: Context, argsBuffer: Buffer): Response | undefined {
    switch (method) {
      {{#each methods}}
      {{#if (ne @key ../initialize)}}
      case Method.{{uppercase @key}}:
        return impl.{{@key}}(state, user, ctx, {{makeRequestName @key}}.decode(argsBuffer));
      {{/if}}
      {{/each}}
      default:
        return undefined;
    }
  },
  {{#if tick}}
  onTick(state: State, ctx: Context, timeDelta: number): void {
    impl.onTick(state, ctx, timeDelta);
  },
  {{/if}}
  getUserState(state: State, user: UserData) {
    return impl.getUserState(state, user);
  },
  changed(): boolean {
    const res = changed;
    changed = false;
    return res;
  },
};
