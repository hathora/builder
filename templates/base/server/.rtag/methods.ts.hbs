import {
  UserData,
  {{userState}} as UserState,
  {{#each methods}}
  {{makeRequestName @key}},
  {{/each}}
} from "./types";

export interface Context {
  rand(): number;
  randInt(limit?: number): number;
  time(): number;
}

export interface OkResponse {
  type: "ok";
}
export interface ErrorResponse {
  type: "error";
  error?: {{error.typeString}};
}
export type Response = OkResponse | ErrorResponse;
export const Response: { ok: () => OkResponse; error: (error?: {{error.typeString}}) => ErrorResponse } = {
  ok: () => ({
    type: "ok",
  }),
  error: (error?: {{error.typeString}}) => ({
    type: "error",
    error,
  }),
};

type State =
  | undefined
  | string
  | number
  | boolean
  | readonly State[]
  | { [k: string]: State }
  | Set<State>
  | Map<State, State>
  | (object & { _modCnt: number });
export interface Methods<T extends State> {
  {{#each methods}}
  {{#if (eq @key ../initialize)}}
  {{../initialize}}(user: UserData, ctx: Context, request: {{makeRequestName @key}}): T;
  {{else}}
  {{@key}}(state: T, user: UserData, ctx: Context, request: {{makeRequestName @key}}): Response;
  {{/if}}
  {{/each}}
  getUserState(state: T, user: UserData): UserState;
  {{#if tick}}
  onTick(state: T, ctx: Context, timeDelta: number): void;
  {{/if}}
}
