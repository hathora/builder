import { LsotClient } from "./client";
import { LitElement, html, customElement, property } from "lit-element";

function connect(userId: string, stateId: string) {
  return LsotClient.connect(
    userId,
    stateId,
    (state) => (document.getElementById("state")!.innerHTML = JSON.stringify(state, null, 2))
  );
}

function setMetadata(userName: string, stateId: string) {
  const urlParams = new URLSearchParams();
  urlParams.set("stateId", stateId);
  urlParams.set("userName", userName);
  history.pushState({}, "", window.location.pathname + "?" + urlParams.toString());
}

const name = prompt("Enter username")!;
LsotClient.registerUser(name)
  .then((userId) => {
    const urlParams = new URLSearchParams(window.location.search);
    const stateId = urlParams.get("stateId") || prompt("Enter stateId (or enter if creating new)");
    if (stateId != null && stateId.length > 0) {
      setMetadata(name, stateId);
      return connect(userId, stateId);
    } else {
      return LsotClient.createState(userId).then((stateId) => {
        setMetadata(name, stateId);
        return connect(userId, stateId);
      });
    }
  })
  .then((client) => {
    (window as any).client = client;
    (window as any).sendData = (method: string, ...elmIds: string[]) => {
      const elms = elmIds.map((elmId) => document.getElementById(method + "_" + elmId));
      const values = elms.map((elm) => (elm as any).value);
      console.log(method, values);
    };
  });

@customElement("numeric-input")
class NumericInput extends LitElement {
  @property({ type: Number }) value: number | undefined;

  render() {
    return html`<input type="number" @change=${this.onChange} />`;
  }

  private onChange = (e: Event) => {
    const target = e.target as HTMLInputElement;
    this.value = new Number(target.value).valueOf();
  };
}

@customElement("boolean-input")
class BooleanInput extends LitElement {
  @property({ type: Boolean }) value: boolean | undefined;

  render() {
    return html`<input type="checkbox" @change=${this.onChange} />`;
  }

  private onChange = (e: Event) => {
    const target = e.target as HTMLInputElement;
    this.value = target.checked;
  };
}

@customElement("enum-input")
class EnumInput extends LitElement {
  @property({ type: Number }) value: number | undefined;
  @property({ type: String }) selectedLabel: string | undefined;
  @property({ type: Boolean }) closed: boolean = true;

  render() {
    return html`<div @click=${this.onDropdownClick}>${this.selectedLabel || "Select a value..."}</div>
      <ul style="${this.closed ? "display: none" : ""}" @click=${this.onSelect}>
        <slot></slot>
      </ul>`;
  }

  private onDropdownClick = (e: Event) => {
    this.closed = !this.closed;
  };

  private onSelect = (e: Event) => {
    const target: any = e.target;
    this.value = target.value;
    this.selectedLabel = target.textContent;
    this.closed = true;
  };
}

@customElement("array-input")
class ArrayInput extends LitElement {
  @property({ type: String }) type: "enum" | "boolean" | "number" | "string" | undefined;
  @property({ type: Array }) value: any[] = [];
  @property({ type: Array }) options: { value: number | boolean; label: string }[] = [];
  @property({ type: Boolean }) distinct: boolean = false;

  render() {
    const optionsToShow = this.distinct
      ? this.options.filter((o) => !this.value.includes(o.value))
      : this.options;
    return html`<input id="${this.id}_input" type="text" @change=${this.onChange} />
      <ul @click=${this.onSelect}>
        ${optionsToShow.map((o) => html`<li value="${o.value}">${o.label}</li>`)}
      </ul>`;
  }

  private onChange = (e: Event) => {
    const target = e.target as HTMLInputElement;
    this.updateValues(target.value, target);
  };

  private onSelect = (e: Event) => {
    const target: any = e.target;
    const input = this.shadowRoot!.getElementById(`${this.id}_input`) as HTMLInputElement;
    this.updateValues(`${input.value},${target.textContent}`, input);
  };

  private updateValues(newInputStr: string, inputElement: HTMLInputElement) {
    const inputs = this.distinct
      ? newInputStr.split(",").filter((s, idx, self) => self.indexOf(s) === idx)
      : newInputStr.split(",");
    switch (this.type) {
      case "enum": {
        const validatedInputs = inputs
          .map((i) => this.options.find((o) => o.label === i))
          .filter((i) => i !== undefined);
        this.value = validatedInputs.map((i) => Number(i!.value));
        inputElement.value = validatedInputs.map((i) => i!.label).join(",");
        break;
      }
      case "boolean": {
        const validatedInputs = inputs
          .map((i) => this.options.find((o) => o.label === i))
          .filter((i) => i !== undefined);
        this.value = validatedInputs.map((i) => Boolean(i!.value));
        inputElement.value = validatedInputs.map((i) => i!.label).join(",");
      }
      case "number": {
        const validatedInputs = inputs.filter((i) => i.trim() !== "" && !isNaN(Number(i)));
        this.value = validatedInputs.map((i) => Number(i));
        inputElement.value = validatedInputs.join(",");
        break;
      }
      case "string": {
        const validatedInputs = inputs.filter((i) => i.trim() !== "");
        this.value = validatedInputs;
        inputElement.value = validatedInputs.join(",");
        break;
      }
      default: {
        this.value = [];
        inputElement.value = "Invalid data type";
      }
    }
  }
}
