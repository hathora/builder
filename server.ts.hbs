import WebSocket from "ws";
import express from "express";
import Bundler from "parcel-bundler";
import { reload } from "import-reload";
import * as http from "http";
import * as path from "path";

const app = express();
const server = http.createServer(app);
const wss = new WebSocket.Server({ noServer: true });
const bundler = new Bundler(path.join(__dirname, "index.html"), {
  cache: false,
});

interface Client {
  userId: string;
  socket: WebSocket;
}

interface UpdateRequest {
  method: string;
  args: any;
}

const states: Map<string, any> = new Map();
const users: Map<string, any> = new Map();
const connections: Map<string, Set<Client>> = new Map();

async function main() {
  const impl = await reload(
    () => import("../impl"),
    (Impl) => new Impl.Impl()
  );

  app.use(express.json());
  app.post("/register", (req, res) => {
    const userData = req.body;
    const userId = Math.random().toString(36).substring(2);
    users.set(userId, userData);
    res.json({ userId });
  });
  app.post("/new", (req, res) => {
    const userId = req.query.userId;
    const userData = users.get(userId)!;
    const state = impl.{{initialize}}(userData, req.body);
    const stateId = Math.random().toString(36).substring(2);
    states.set(stateId, state);
    res.json({ stateId });
  });
  app.use(bundler.middleware());

  server.on("upgrade", (req, socket, head) => {
    const stateId = req.url.substring(1);
    wss.handleUpgrade(req, socket, head, (ws) => {
      ws.once("message", (userId) => {
        if (!states.has(stateId) || !users.has(userId)) {
          ws.terminate();
        } else {
          handleConnection(stateId, userId, ws);
        }
      });
    });
  });

  function handleConnection(stateId: string, userId: string, socket: WebSocket) {
    const state = states.get(stateId)!;
    const userData = users.get(userId)!;
    addConnection(stateId, userId, socket);
    socket.send(JSON.stringify(impl.getUserState(state, userData)));
    socket.on("close", () => {
      deleteConnection(stateId, userId, socket);
    });

    socket.on("message", (data) => {
      const { method, args }: UpdateRequest = JSON.parse(data as string);
      impl[method as keyof typeof impl](state, userData, args);
      broadcastUpdates(stateId, state);
    });
  }

  function addConnection(stateId: string, userId: string, socket: WebSocket) {
    if (!connections.has(stateId)) {
      connections.set(stateId, new Set([{ userId, socket }]));
    } else {
      connections.get(stateId)!.add({ userId, socket });
    }
  }

  function deleteConnection(stateId: string, userId: string, socket: WebSocket) {
    connections.get(stateId)!.delete({ userId, socket });
    if (connections.get(stateId)!.size === 0) {
      connections.delete(stateId);
    }
  }

  function broadcastUpdates(stateId: string, state: any) {
    connections.get(stateId)!.forEach(({ userId, socket }) => {
      const userData = users.get(userId)!;
      const userState = impl.getUserState(state, userData);
      socket.send(JSON.stringify(userState));
    });
  }

  server.listen(3000, () => {
    console.log("listening on *:3000");
  });
}

main();
